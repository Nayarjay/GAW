{"version":3,"file":"js/babylonBundle.js","mappings":"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","sources":["webpack://gaw/webpack/bootstrap","webpack://gaw/webpack/runtime/define property getters","webpack://gaw/webpack/runtime/hasOwnProperty shorthand","webpack://gaw/./game/End.js","webpack://gaw/./game/CustomModels.js","webpack://gaw/./game/CharacterController.js","webpack://gaw/./game/PlayerLevel1.js","webpack://gaw/./game/scene2.js","webpack://gaw/./game/CharacterController2.js","webpack://gaw/./game/PlayerLevel2.js","webpack://gaw/./game/scene3.js","webpack://gaw/./game/CharacterController3.js","webpack://gaw/./game/PlayerLevel3.js","webpack://gaw/./game/BowlingPin.js","webpack://gaw/./game/scene4.js","webpack://gaw/./game/Menu.js","webpack://gaw/./game/SceneManager.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var canvas = document.getElementById(\"renderCanvas\");\r\nvar engine = new BABYLON.Engine(canvas, true);\r\nvar scene = new BABYLON.Scene(engine);\r\nimport { CustomModels } from './CustomModels.js';\r\nimport * as sceneManager from './SceneManager.js';\r\nvar createScene = function () {\r\n    // Ajoutez une lumière\r\n    var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n    var camera = new BABYLON.FreeCamera(\"camera\", new BABYLON.Vector3(0, 4, -12.5), scene);\r\n\r\n    camera.attachControl();\r\n    if(sceneManager.winCountPlayer1 > sceneManager.winCountPlayer2){\r\n        playerWin(-4,0,-1);\r\n        playerLoose(2,0,0);\r\n\r\n    }else{\r\n        playerWin(2,0,-1);\r\n        playerLoose(-4,0,0);\r\n    }\r\n\r\n    scene.debugLayer.show();\r\n    displayControlUI();\r\n    loadEndScene();\r\n    //hideControlUI();\r\n    return scene;\r\n};\r\nfunction launch(){\r\n    createScene();\r\n\r\n    engine.runRenderLoop(function () {\r\n        \r\n        scene.render();\r\n    });\r\n    \r\n\r\n}\r\n\r\nfunction displayControlUI(){\r\n  \r\n    // Récupération de l'élément par son ID\r\n    var level1 = document.getElementById(\"End\");\r\n \r\n    // Afficher l'élément\r\n    level1.style.display = \"block\";\r\n \r\n }\r\nfunction hideControlUI(){\r\n    // Récupération de l'élément par son ID\r\n    var level1 = document.getElementById(\"End\");\r\n\r\n    // Afficher l'élément\r\n    level1.style.display = \"none\";\r\n\r\n}\r\nfunction playerLoose(x,y,z){\r\n    \r\n    \r\n    BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Loose.glb\", scene, (meshes) => {\r\n        console.log(\"Chargement réussi coliseum\", meshes);\r\n     \r\n        let mesh = meshes[0];\r\n       \r\n        mesh.name =\"playerLoose\"\r\n        \r\n       \r\n        mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n        \r\n        \r\n    \r\n      \r\n      \r\n    }, undefined, undefined, \".glb\");\r\n\r\n\r\n\r\n}\r\nfunction playerWin(x,y,z){\r\n  \r\n    BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"victory.glb\", scene, (meshes) => {\r\n        console.log(\"Chargement réussi coliseum\", meshes);\r\n     \r\n        let mesh = meshes[0];\r\n       \r\n        mesh.name =\"playerWin\"\r\n        \r\n       \r\n        mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n        \r\n        \r\n    \r\n      \r\n      \r\n    }, undefined, undefined, \".glb\");\r\n}\r\n\r\nfunction loadEndScene(x,y,z){\r\n    \r\n    BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"recommencer.glb\", scene, (meshes) => {\r\n        console.log(\"Chargement réussi end scene\", meshes);\r\n     \r\n        let mesh = meshes[0];\r\n       \r\n        mesh.name =\"EndScene\"\r\n        \r\n       \r\n        mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n        \r\n        \r\n    \r\n      \r\n      \r\n    }, undefined, undefined, \".glb\");\r\n\r\n}\r\nexport {  scene, launch };\r\n\r\n","\r\n\r\n\r\nexport class CustomModels {\r\n\r\n    constructor(scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    \r\n    \r\n    /** ######################################################################## LEVEL2 3D MODEL #########################################################################**/\r\n\r\n    // Crée un modèle d'arbre 3D et le positionne aux coordonnées spécifiées (x, y, z)\r\n    async CreateTree(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Tree.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi arbre\", meshes);\r\n         \r\n            tree = meshes[0];\r\n            tronc = meshes[1];\r\n            tronc.name =\"tronc\"\r\n            \r\n           \r\n            tree.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            \r\n\r\n            var troncAggregate =new BABYLON.PhysicsAggregate(tronc, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);\r\n            troncAggregate.shape.isTrigger =  true;\r\n\r\n            \r\n            var troncAggregate2 =new BABYLON.PhysicsAggregate(tronc, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);\r\n            \r\n        \r\n          \r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n     \r\n    \r\n        return { boundingBox };\r\n    }\r\n\r\n    async CreatePineTree(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        return   BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Pine Tree with Snow.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi arbre\", meshes);\r\n            meshes[0].scaling.x = 3\r\n            meshes[0].scaling.y = 2\r\n            meshes[0].scaling.z = 4\r\n            tree = meshes[0];\r\n            tronc = meshes[1];\r\n            tronc.name =\"tronc\"\r\n            console.log(tronc.name);\r\n            \r\n           \r\n            tree.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 1, 3),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(3, 3, 5),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n            const shapeBox2 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 1, 3),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(3, 3, 5),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n            \r\n            var troncAggregate =new BABYLON.PhysicsAggregate(tronc, shapeBox1, { mass: 0 }, this.scene);\r\n            troncAggregate.shape.isTrigger =  true;\r\n            //troncAggregate.shape.\r\n\r\n            \r\n            var troncAggregate2 =new BABYLON.PhysicsAggregate(tronc, shapeBox2, { mass: 0 }, this.scene);\r\n           \r\n            \r\n        \r\n           //return boundingBox;\r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n     \r\n    \r\n       \r\n    }\r\n\r\n\r\n\r\n    CreateSnowManOnSki(x, y, z,parent) {\r\n        let mesh; // Déclaration de mesh à un niveau supérieur pour qu'il soit accessible en dehors de la fonction de rappel\r\n    \r\n        // Charger le modèle 3D\r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"snowman_on_skis.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi SnowMan\", meshes);\r\n            mesh = meshes[0]; // Assignation de meshes[0] à mesh\r\n            mesh.name = \"SnowMan\";\r\n            mesh.position = new BABYLON.Vector3(x, y, z); // Positionne le modèle une fois chargé\r\n            mesh.setParent(parent);\r\n \r\n            //mesh.rotationQuaternion._y = 85;\r\n\r\n          \r\n        }, undefined, undefined, \".glb\");\r\n    \r\n        return { mesh }; // Retourne mesh\r\n    }\r\n    \r\n    \r\n  \r\n    \r\n   \r\n    async CreateSceneProd(x, y, z) {\r\n       \r\n    }\r\n    async CreatePlayer(x, y, z) {\r\n        \r\n    }\r\n      \r\n    async Zone(x, y, z) {\r\n      \r\n     \r\n    }\r\n\r\n    async plane(x, y, z,width,height,scene) {\r\n      \r\n        let subdivisions = 1\r\n        \r\n        var ground = BABYLON.MeshBuilder.CreateGround(\"ground\", { width, height, subdivisions },scene);\r\n        ground.position.addInPlace(new BABYLON.Vector3(x, y, z)); \r\n        // Créez un quaternion pour représenter la rotation souhaitée\r\n       \r\n       \r\n        ground.rotation = new BABYLON.Vector3(-0.1, 0, 0);\r\n\r\n        \r\n        //create physic impostor\r\n        var groundAggregate =new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);\r\n        \r\n            // Appliquez la rotation au sol\r\n      \r\n        // create Materials\r\n        var groundMaterial = new BABYLON.StandardMaterial(\"groundMaterial\", scene);\r\n        groundMaterial.diffuseColor = new BABYLON.Color3(0.92, 0.29, 0.28); // Rouge doux\r\n         // Set position of the ground\r\n        //ground.position = new BABYLON.Vector3(x, y, z);\r\n        \r\n        //add material to the object\r\n        ground.material = groundMaterial;\r\n        //console.log(ground);\r\n        return ground;\r\n     \r\n    }\r\n\r\n    async flatplane(x, y, z,width,height,scene) {\r\n      \r\n        let subdivisions = 1\r\n        \r\n        var ground = BABYLON.MeshBuilder.CreateGround(\"ground\", { width, height, subdivisions },scene);\r\n        ground.position.addInPlace(new BABYLON.Vector3(x, y, z)); \r\n        // Créez un quaternion pour représenter la rotation souhaitée\r\n       \r\n       \r\n        ground.rotation = new BABYLON.Vector3(0, 0, 0);\r\n\r\n        \r\n        //create physic impostor\r\n        var groundAggregate =new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);\r\n        \r\n            // Appliquez la rotation au sol\r\n      \r\n        // create Materials\r\n        var groundMaterial = new BABYLON.StandardMaterial(\"groundMaterial\", scene);\r\n        groundMaterial.diffuseColor = new BABYLON.Color3(0.92, 0.29, 0.28); // Rouge doux\r\n         // Set position of the ground\r\n        //ground.position = new BABYLON.Vector3(x, y, z);\r\n        \r\n        //add material to the object\r\n        ground.material = groundMaterial;\r\n        //console.log(ground);\r\n        return ground;\r\n     \r\n    }\r\n    async createDeadTree(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Dead Trees With Snow.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi arbre\", meshes);\r\n            \r\n            meshes[0].scaling.x = 30\r\n            meshes[0].scaling.y = 20\r\n            meshes[0].scaling.z = 20\r\n            let globalMesh = meshes[0];\r\n            tronc = meshes[1];\r\n\r\n            tronc.name =\"tronc\"\r\n            console.log(tronc.name);\r\n\r\n            const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 1, 3),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(30, 30, 30),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n           \r\n            \r\n           \r\n            globalMesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            \r\n\r\n            var troncAggregate =new BABYLON.PhysicsAggregate(tronc, shapeBox1, { mass: 0 }, this.scene);\r\n            troncAggregate.shape.isTrigger =  true;\r\n\r\n            \r\n            var troncAggregate2 =new BABYLON.PhysicsAggregate(tronc, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);\r\n          \r\n\r\n  \r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n     \r\n    \r\n        return { boundingBox };\r\n    }\r\n    async createSnowTree(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Snow Tree.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi arbre\", meshes);\r\n            \r\n            meshes[0].scaling.x = 10\r\n            meshes[0].scaling.y = 10\r\n            meshes[0].scaling.z = 10\r\n            let globalMesh = meshes[0];\r\n            tronc = meshes[1];\r\n\r\n            tronc.name =\"tronc\"\r\n            console.log(tronc.name);\r\n\r\n            const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 0, -1),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(5, 10, 5),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n            const shapeBox2 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 0, -1),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(5, 10, 5),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n           \r\n            \r\n           \r\n            globalMesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            \r\n\r\n            var troncAggregate =new BABYLON.PhysicsAggregate(tronc, shapeBox1, { mass: 0 }, this.scene);\r\n            troncAggregate.shape.isTrigger =  true;\r\n\r\n            \r\n            var troncAggregate2 =new BABYLON.PhysicsAggregate(tronc,shapeBox2, { mass: 0 }, this.scene);\r\n          \r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n     \r\n    \r\n        return { boundingBox };\r\n    }\r\n    async createLitleSnowTree(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Pine Tree with Snow two.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi arbre\", meshes);\r\n            \r\n            meshes[0].scaling.x = 10\r\n            meshes[0].scaling.y = 10\r\n            meshes[0].scaling.z = 10\r\n\r\n            let globalMesh = meshes[0];\r\n            tronc = meshes[1];\r\n\r\n            tronc.name =\"tronc\"\r\n            console.log(tronc.name);\r\n\r\n            const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 0, -1),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(5, 10, 5),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n            const shapeBox2 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 0, -1),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(5, 10, 5),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n           \r\n            \r\n           \r\n            globalMesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            \r\n\r\n            var troncAggregate =new BABYLON.PhysicsAggregate(tronc, shapeBox1, { mass: 0 }, this.scene);\r\n            troncAggregate.shape.isTrigger =  true;\r\n\r\n            \r\n            var troncAggregate2 =new BABYLON.PhysicsAggregate(tronc,shapeBox2, { mass: 0 }, this.scene);\r\n      \r\n        \r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n     \r\n    \r\n        return { boundingBox };\r\n    }\r\n    async createSnowMan(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"SnowManRotated.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi arbre\", meshes);\r\n            \r\n            meshes[0].scaling.x = 1\r\n            meshes[0].scaling.y = 1\r\n            meshes[0].scaling.z = 1\r\n      \r\n            let globalMesh = meshes[0];\r\n            \r\n            tronc = meshes[1];\r\n            tronc.name =\"tronc\"\r\n            console.log(\"SNOWMAN \"+globalMesh.name);\r\n\r\n            const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 4, 0),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(5, 10, 5),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n            \r\n            const shapeBox2 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 4, -1),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(5, 10, 5),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n           \r\n            \r\n           \r\n            globalMesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            \r\n\r\n            var troncAggregate =new BABYLON.PhysicsAggregate(tronc, shapeBox1, { mass: 0 }, this.scene);\r\n            troncAggregate.shape.isTrigger =  true;\r\n\r\n            \r\n            var troncAggregate2 =new BABYLON.PhysicsAggregate(tronc,shapeBox2, { mass: 0 }, this.scene);\r\n      \r\n        \r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n     \r\n    \r\n        return { boundingBox };\r\n    }\r\n\r\n    CreateRampe1(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        \r\n        let bigMesh = BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"rampe_2.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi\", meshes);\r\n \r\n            meshes[0].scaling.x = 5\r\n            meshes[0].scaling.y = 5\r\n            meshes[0].scaling.z = 5\r\n   \r\n           \r\n            let mesh = meshes[0];\r\n            console.log(meshes[1].name);\r\n            //tronc = meshes[1];\r\n            mesh.name =\"Rampe\"\r\n            let elment =meshes[1] ;\r\n           \r\n            mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n        \r\n             \r\n\r\n            var troncAggregate =new BABYLON.PhysicsAggregate(elment, BABYLON.PhysicsShapeType.MESH, { mass: 0 }, this.scene);\r\n           \r\n\r\n            \r\n           // var troncAggregate2 =new BABYLON.PhysicsAggregate(tronc, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);\r\n          \r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n        bigMesh.position= new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n    \r\n        return {  bigMesh};\r\n    }\r\n\r\n    createSnowMount(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        \r\n        let bigMesh = BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Rock Forms 3 (White).glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi\", meshes);\r\n           \r\n            meshes[0].scaling.x = 150\r\n            meshes[0].scaling.y = 150\r\n            meshes[0].scaling.z = 150\r\n\r\n\r\n            const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 4, 0),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(10, 10, 20),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n            \r\n       \r\n           \r\n            let mesh = meshes[0];\r\n            mesh.name =\"tronc\"\r\n            console.log(meshes[1].name);\r\n            //tronc = meshes[1];\r\n            //mesh.name =\"tronc\"\r\n            let element =meshes[1] ;\r\n            element.name =\"tronc\"\r\n            mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n        \r\n             \r\n          \r\n            \r\n            var troncAggregate =new BABYLON.PhysicsAggregate(mesh, shapeBox1, { mass: 0 }, this.scene);\r\n            troncAggregate.shape.isTrigger =  true;\r\n\r\n            \r\n            var troncAggregate2 =new BABYLON.PhysicsAggregate(element, BABYLON.PhysicsShapeType.MESH, { mass: 0 }, this.scene);\r\n          \r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n        bigMesh.position= new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n    \r\n        return {  bigMesh};\r\n    }\r\n\r\n\r\n    createFinalScene2(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n       \r\n        \r\n        let bigMesh = BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"finalscene2.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi\", meshes);\r\n           \r\n            //meshes[0].scaling.x = 150\r\n            //meshes[0].scaling.y = 150\r\n            //meshes[0].scaling.z = 150\r\n\r\n\r\n            const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n                new BABYLON.Vector3(0, 0, 0),        // center of the box\r\n                new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                new BABYLON.Vector3(10, 10, 20),      // dimensions of the box\r\n                this.scene                                // scene of the shape\r\n            );\r\n            \r\n       \r\n           \r\n            let mesh = meshes[0];\r\n            mesh.name =\"tronc\"\r\n            console.log(meshes[2].name);\r\n            //tronc = meshes[1];\r\n            //mesh.name =\"tronc\"\r\n            //let element =meshes[1] ;\r\n            let element = this.scene.getMeshByName(\"Cube (sol)\");\r\n            //let element2 = this.scene.getMeshByName(\"Cube (sol)\") ;\r\n            //let element3 = this.scene.getMeshByUniqueId(769) ;\r\n\r\n            //element.name =\"tronc\"\r\n            mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n\r\n            //console.log();\r\n        \r\n            let i =1;\r\n            while( i <  meshes.length){\r\n                \r\n                var troncAggregate =new BABYLON.PhysicsAggregate(meshes[i], BABYLON.PhysicsShapeType.MESH, { mass: 0 }, this.scene);\r\n                i++\r\n            }\r\n            \r\n          \r\n          \r\n          \r\n        }, undefined, undefined, \".glb\");\r\n\r\n        bigMesh.position= new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n    \r\n        return {  bigMesh};\r\n    }\r\n    \r\n    \r\n    \r\n    /** ######################################################################## Scene3 3D MODEL #########################################################################**/\r\n\r\n\r\n        // Crée un modèle d'arbre 3D et le positionne aux coordonnées spécifiées (x, y, z)\r\n        CreatePlateform(x, y, z) {\r\n            let tree;\r\n            let boundingBox;\r\n            let tronc;\r\n        \r\n            BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"plateforme_scene3.glb\", this.scene, (meshes) => {\r\n                console.log(\"Chargement réussi plateform\", meshes);\r\n            \r\n                let mesh = meshes[0];\r\n                //tronc = meshes[1];\r\n                mesh.name =\"colision\"\r\n                \r\n            \r\n                mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n                \r\n                \r\n                let i =1;\r\n                while( i <  meshes.length){\r\n                    \r\n                    var troncAggregate =new BABYLON.PhysicsAggregate(meshes[i], BABYLON.PhysicsShapeType.MESH, { mass: 0 }, this.scene);\r\n                    i++\r\n                }\r\n            \r\n            \r\n            }, undefined, undefined, \".glb\");\r\n\r\n        \r\n\r\n            return { boundingBox };\r\n        }\r\n\r\n        CreatePlateformlevel2(x, y, z) {\r\n            let tree;\r\n            let boundingBox;\r\n            let tronc;\r\n        \r\n            BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"scene3.glb\", this.scene, (meshes) => {\r\n                console.log(\"Chargement réussi plateform level2\", meshes);\r\n            \r\n                let mesh = meshes[0];\r\n                //tronc = meshes[1];\r\n                mesh.name =\"colision\"\r\n                \r\n            \r\n                mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n                \r\n                \r\n                let i =1;\r\n                while( i <  meshes.length){\r\n                    \r\n                    var troncAggregate =new BABYLON.PhysicsAggregate(meshes[i], BABYLON.PhysicsShapeType.MESH, { mass: 0 }, this.scene);\r\n                    i++\r\n                }\r\n            \r\n            \r\n            }, undefined, undefined, \".glb\");\r\n\r\n        \r\n\r\n            return { boundingBox };\r\n        }\r\n\r\n\r\n\r\n /** ######################################################################## Scene4 3D MODEL #########################################################################**/\r\n    // Crée un modèle d'arbre 3D et le positionne aux coordonnées spécifiées (x, y, z)\r\n    CreatePlateform_Scene4(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n    \r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"scene4_gameplay_ELEMENT.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi plateform\", meshes);\r\n        \r\n            let mesh = meshes[0];\r\n            //tronc = meshes[1];\r\n            mesh.name =\"colision\"\r\n            \r\n        \r\n            mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            \r\n            let i =1;\r\n            while( i <  meshes.length){\r\n                \r\n                var troncAggregate =new BABYLON.PhysicsAggregate(meshes[i], BABYLON.PhysicsShapeType.MESH, { mass: 0 }, this.scene);\r\n                //troncAggregate.body.setCollisionCallbackEnabled(true);\r\n                i++\r\n            }\r\n        \r\n        \r\n        }, undefined, undefined, \".glb\");\r\n\r\n    \r\n\r\n        return { boundingBox };\r\n    }\r\n\r\n    CreateBowlingPlatform(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n    \r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"scene_de_bowling.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi plateform\", meshes);\r\n        \r\n            let mesh = meshes[0];\r\n            //tronc = meshes[1];\r\n            mesh.name =\"colision\"\r\n            \r\n        \r\n            mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            \r\n            let i =1;\r\n            while( i <  meshes.length){\r\n                \r\n                var troncAggregate =new BABYLON.PhysicsAggregate(meshes[i], BABYLON.PhysicsShapeType.MESH, { mass: 0 }, this.scene);\r\n                //troncAggregate.body.setCollisionCallbackEnabled(true);\r\n                i++\r\n            }\r\n        \r\n        \r\n        }, undefined, undefined, \".glb\");\r\n\r\n    \r\n\r\n        return { boundingBox };\r\n    }\r\n\r\n    CreateBowlingBall(x, y, z) {\r\n        let tree;\r\n        let boundingBox;\r\n        let tronc;\r\n    \r\n        BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Spiky Ball.glb\", this.scene, (meshes) => {\r\n            console.log(\"Chargement réussi ball\", meshes);\r\n        \r\n            let mesh = meshes[0];\r\n          \r\n            mesh.name =\"ball\"\r\n            \r\n        \r\n            mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n            \r\n            var troncAggregate =new BABYLON.PhysicsAggregate(mesh, BABYLON.PhysicsShapeType.SPHERE, { mass: 0 }, this.scene);\r\n         \r\n        \r\n        }, undefined, undefined, \".glb\");\r\n\r\n    \r\n\r\n        return { boundingBox };\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /** ######################################################################## MENU 3D MODEL #########################################################################**/\r\n\r\n\r\n\r\n        // Crée un modèle d'arbre 3D et le positionne aux coordonnées spécifiées (x, y, z)\r\n        CreateColiseum(x, y, z) {\r\n            let tree;\r\n            let boundingBox;\r\n            let tronc;\r\n           \r\n            BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"coliseum.glb\", this.scene, (meshes) => {\r\n                console.log(\"Chargement réussi coliseum\", meshes);\r\n             \r\n                let mesh = meshes[0];\r\n                //tronc = meshes[1];\r\n                mesh.name =\"coliseum\"\r\n                \r\n               \r\n                mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n                \r\n                \r\n            \r\n              \r\n              \r\n            }, undefined, undefined, \".glb\");\r\n    \r\n         \r\n        \r\n            return { boundingBox };\r\n        }\r\n\r\n               // Crée un modèle d'arbre 3D et le positionne aux coordonnées spécifiées (x, y, z)\r\n        CreateColiseum(x, y, z) {\r\n            let tree;\r\n            let boundingBox;\r\n            let tronc;\r\n           \r\n            BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"coliseum.glb\", this.scene, (meshes) => {\r\n                console.log(\"Chargement réussi coliseum\", meshes);\r\n             \r\n                let mesh = meshes[0];\r\n                //tronc = meshes[1];\r\n                mesh.name =\"coliseum\"\r\n                \r\n               \r\n                mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n                \r\n                \r\n    \r\n                //var troncAggregate =new BABYLON.PhysicsAggregate(tronc, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);\r\n               // troncAggregate.shape.isTrigger =  true;\r\n    \r\n                \r\n                //var troncAggregate2 =new BABYLON.PhysicsAggregate(tronc, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, this.scene);\r\n\r\n                 \r\n            \r\n              \r\n              \r\n            }, undefined, undefined, \".glb\");\r\n    \r\n         \r\n        \r\n            return { boundingBox };\r\n        }\r\n\r\n          // Crée un modèle d'arbre 3D et le positionne aux coordonnées spécifiées (x, y, z)\r\n        CreateMenu3dScene(x, y, z) {\r\n            let tree;\r\n            let boundingBox;\r\n            let tronc;\r\n           \r\n            BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"menu.glb\", this.scene, (meshes) => {\r\n                console.log(\"Chargement réussi du menu\", meshes);\r\n             \r\n                let mesh = meshes[0];\r\n                //tronc = meshes[1];\r\n                mesh.name =\"fondMenu\"\r\n                \r\n               \r\n                mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n                \r\n                \r\n            \r\n              \r\n              \r\n            }, undefined, undefined, \".glb\");\r\n    \r\n         \r\n        \r\n            return { boundingBox };\r\n        }\r\n\r\n        Createlevel1(x, y, z) {\r\n            let tree;\r\n            let boundingBox;\r\n            let tronc;\r\n        \r\n            BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"level2Map.glb\", this.scene, (meshes) => {\r\n                console.log(\"Chargement réussi plateform\", meshes);\r\n            \r\n                let mesh = meshes[0];\r\n                //tronc = meshes[1];\r\n                mesh.name =\"colision\"\r\n                \r\n            \r\n                mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n                \r\n                \r\n                let i =1;\r\n                while( i <  meshes.length){\r\n                    \r\n                    var troncAggregate =new BABYLON.PhysicsAggregate(meshes[i], BABYLON.PhysicsShapeType.MESH, { mass: 0 }, this.scene);\r\n                    //troncAggregate.body.setCollisionCallbackEnabled(true);\r\n                    i++\r\n                }\r\n            \r\n            \r\n            }, undefined, undefined, \".glb\");\r\n    \r\n        \r\n    \r\n            return { boundingBox };\r\n        }\r\n        \r\n\r\n\r\n\r\n\r\n    \r\n   \r\n}\r\n","class CharacterController {\r\n    constructor(canvas , engine, character,forward,backward,left,right) {\r\n        this.setupKeyboardInput(canvas, engine, character,forward,backward,left,right);\r\n    }\r\n\r\n    setupKeyboardInput(canvas, engine, character,forwardI,backward,left,right) {\r\n        this.keys = {};\r\n\r\n        // Écoute l'événement \"keydown\" (touche enfoncée) sur le canvas.\r\n        canvas.addEventListener('keydown', (event) => {\r\n            this.keys[event.key] = true;\r\n        });\r\n\r\n        // Écoute l'événement \"keyup\" (touche relâchée) sur le canvas.\r\n        canvas.addEventListener('keyup', (event) => {\r\n            this.keys[event.key] = false;\r\n        });\r\n\r\n        // Démarre la boucle de rendu du moteur Babylon.js.\r\n        engine.runRenderLoop(() => {\r\n            // Vérifie l'état des touches dans l'objet \"keys\" et effectue des actions en conséquence.\r\n\r\n            if (this.keys[forwardI]) {\r\n                //console.log('Touche Z enfoncée');\r\n                \r\n                let forward = character.transformNode.forward.scale(-5);\r\n               //console.log(forward);\r\n\r\n                character.applyForce(forward , character.transformNode.position);\r\n                character.setAngularVelocity(BABYLON.Vector3.ZeroReadOnly);\r\n          \r\n            }\r\n\r\n            if (this.keys[backward]) {\r\n                //console.log('Touche S enfoncée');\r\n                character.applyForce(new BABYLON.Vector3(0, 0, 5), new BABYLON.Vector3(0, 0, 0));\r\n                character.setAngularVelocity(BABYLON.Vector3.ZeroReadOnly);\r\n                //character.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));\r\n                //charater.position.z += 0.1; // Déplace le personnage vers l'avant (positif sur l'axe z).\r\n            }\r\n\r\n            if (this.keys[left]) {\r\n                //console.log('Touche Q enfoncée');\r\n                character.applyForce(new BABYLON.Vector3(5, 0, 0), new BABYLON.Vector3(0, 0, 0));\r\n                character.setAngularVelocity(new BABYLON.Vector3(0, -0.5, 0));\r\n                //character.setAngularVelocity(BABYLON.Vector3.ZeroReadOnly);\r\n                //character.position.x += 0.1; // Déplace le personnage vers la gauche (positif sur l'axe x).\r\n            }\r\n\r\n            if (this.keys[right]) {\r\n                //console.log('Touche D enfoncée');\r\n                character.applyForce(new BABYLON.Vector3(-5, 0, 0), new BABYLON.Vector3(0, 0, 0));\r\n                character.setAngularVelocity(new BABYLON.Vector3(0, 0.5, 0));\r\n                //character.position.x -= 0.1; // Déplace le personnage vers la droite (négatif sur l'axe x).\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nexport default CharacterController;\r\n","\r\nimport CharacterController from './CharacterController.js';\r\nimport { CustomModels } from './CustomModels.js';\r\n\r\nvar canvas2 = document.getElementById(\"renderCanvas\");\r\n//var engine2 = new BABYLON.Engine(canvas2, true);\r\n\r\n//variables\r\n\r\n\r\n\r\nexport class PlayerLevel1 {\r\n\r\n    constructor(scene,engine,name,forward,backward,left,right,x,y,z) {\r\n        this.scene = scene;\r\n        this.engine = engine;\r\n        this.boxBody ;\r\n\r\n        this.testPlayer(scene,engine,name,x,y,z);\r\n        this.enablePlayerControl(forward,backward,left,right);\r\n     \r\n    }\r\n    \r\n\r\n    testPlayer(scene,engine,name,x,y,z){\r\n\r\n        \r\n\r\n\r\n       \r\n        var boxW = 2;\r\n        var boxH = 2;\r\n        var boxD = 2;\r\n\r\n        var box = BABYLON.MeshBuilder.CreateBox(name, {width: boxW, height: boxH, depth: boxD},scene);\r\n        box.isVisible = false;\r\n        //var box2 = BABYLON.MeshBuilder.CreateBox(name, {width: boxW, height: boxH, depth: boxD},scene);\r\n        //box.addChild(snowMan);\r\n        let snowMan = new CustomModels(scene).CreateSnowManOnSki(x,y-0.5,z,box);\r\n      \r\n       \r\n        //box.addChild(box2);\r\n        \r\n        box.rotationQuaternion = BABYLON.Quaternion.Identity();\r\n        box.position = new BABYLON.Vector3(x,y,z);\r\n        \r\n        var boxShape = new BABYLON.PhysicsShapeBox(new BABYLON.Vector3(0,0,0), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(boxW, boxH, boxD), scene);\r\n        var boxBody = new BABYLON.PhysicsBody(box, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);\r\n    \r\n        boxBody.shape = boxShape;\r\n        boxBody.setMassProperties({mass : 1})\r\n    \r\n    \r\n        //add create material add tothe cube\r\n        var blueMaterial = new BABYLON.StandardMaterial(\"groundMaterial\", scene);\r\n        blueMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1); // Rouge doux\r\n        box.material = blueMaterial;\r\n       \r\n        \r\n        boxBody.setCollisionCallbackEnabled(true)\r\n\r\n        //rotate character\r\n      \r\n      \r\n        this.boxBody = boxBody;\r\n        \r\n     \r\n        \r\n      \r\n     \r\n        \r\n    \r\n       \r\n \r\n        return box;\r\n    \r\n        \r\n    }\r\n  \r\n \r\n    enablePlayerControl(forward,backward,left,right){\r\n       let control = new CharacterController(canvas2,this.engine,this.boxBody,forward,backward,left,right);\r\n    }\r\n    \r\n\r\n    destroyPlayer(){\r\n        \r\n        control = null;\r\n    }\r\n\r\n\r\n\r\n}\r\nexport default PlayerLevel1;","\r\nimport CharacterController from './CharacterController.js';\r\nimport { CustomModels } from './CustomModels.js';\r\n\r\nimport {PlayerLevel1} from \"./PlayerLevel1.js\";\r\nimport * as sceneManager from './SceneManager.js';\r\nlet advancedTexture ;\r\n\r\nvar canvas = document.getElementById(\"renderCanvas\");\r\nvar engine = new BABYLON.Engine(canvas, true);\r\nvar scene = new BABYLON.Scene(engine);\r\nvar name = \"level2\";\r\nvar value = \"start\";     \r\n//var player = new PlayerLevel1(scene);\r\n\r\nasync function getInitializedHavok() {\r\n  return await HavokPhysics();\r\n}\r\n\r\nasync function sceneData() {\r\n    //displayControlUI();\r\n    // Ajoutez une lumière hémisphériques\r\n    var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n\r\n    \r\n    const havokInstance = await HavokPhysics();\r\n    // pass the engine to the plugin\r\n    const hk = new BABYLON.HavokPlugin(true, havokInstance);\r\n   \r\n    \r\n\r\n    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0),  hk);\r\n    scene.collisionsEnabled = true;\r\n    \r\n\r\n    var sceneprod = new CustomModels(scene);\r\n    //PART 1 LEVEL\r\n    \r\n    //first plane \r\n    //let plane = sceneprod.plane(5,0,-45,25,150,scene);\r\n  \r\n   \r\n\r\n    let x = -10;\r\n\r\n\r\n//********************************************************** PART 5 LEVEL ******************************************************************************/////////////////\r\n    //rajoute d'un plane\r\n    \r\n\r\n\r\n    //trigger to die and pass\r\n    triggerDie(-1.79, -1.02, -832.37);\r\n    \r\n\r\n    \r\n\r\n    displayControlUI();\r\n\r\n   //testPlayer();\r\n\r\n   let player = new PlayerLevel1(scene,engine,'player1','z','s','q','d',5,170,0);\r\n\r\n   let player2 = new PlayerLevel1(scene,engine,'player2','ArrowUp','ArrowDown','ArrowLeft','ArrowRight',0,170,0);\r\n\r\n    \r\n   //montrer le layer\r\n   //scene.debugLayer.show();\r\n   \r\n   \r\n\r\n    var place = new CustomModels(scene);\r\n    //place.createFinalScene2(4,-24,-970);\r\n   \r\n    place.Createlevel1(0,0,-800)\r\n    \r\n \r\n\r\n    \r\n    let playerMesh = scene.getMeshByName(\"player1\");\r\n    //let playerMesh2 = scene.gezzzzzzztMeshByName(\"player2\");\r\n    //console.log(scene.getMeshByName(\"player\"));\r\n    //console.log(scene.getMeshByUniqueId(6));\r\n    \r\n    eventHandler(hk,player);\r\n   return playerMesh;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nfunction getScene() {\r\n    return scene;\r\n}\r\n\r\n\r\nfunction testPlayer(){\r\n    var boxW = 2;\r\n    var boxH = 2;\r\n    var boxD = 2;\r\n    \r\n    var box = BABYLON.MeshBuilder.CreateBox(\"player\", {width: boxW, height: boxH, depth: boxD},scene);\r\n   \r\n    box.rotationQuaternion = BABYLON.Quaternion.Identity();\r\n    box.position = new BABYLON.Vector3(0,5,0);\r\n\r\n    var boxShape = new BABYLON.PhysicsShapeBox(new BABYLON.Vector3(0,0,0), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(boxW, boxH, boxD), scene);\r\n    var boxBody = new BABYLON.PhysicsBody(box, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);\r\n\r\n    boxBody.shape = boxShape;\r\n    boxBody.setMassProperties({mass : 1})\r\n\r\n\r\n    //add create material add tothe cube\r\n    var blueMaterial = new BABYLON.StandardMaterial(\"groundMaterial\", scene);\r\n    blueMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1); // Rouge doux\r\n    box.material = blueMaterial;\r\n   \r\n    \r\n    boxBody.setCollisionCallbackEnabled(true)\r\n  \r\n   \r\n    \r\n \r\n\r\n \r\n \r\n    \r\n\r\n    //boxBody.applyForce()\r\n    let control = new CharacterController(canvas,scene,engine,boxBody);\r\n    return box;\r\n\r\n    \r\n}\r\n\r\nfunction triggerDie(x,y,z){\r\n\r\n    const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n        new BABYLON.Vector3(0, 0, 0),        // center of the box\r\n        new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n        new BABYLON.Vector3(40, 40, 40),      // dimensions of the box\r\n        scene                                // scene of the shape\r\n    );\r\n    \r\n\r\n    let RainBowMesh = scene.getMeshByName(\"RainBow\");\r\n\r\n    var boxW = 2;\r\n    var boxH = 2;\r\n    var boxD = 2;\r\n\r\n    var box = BABYLON.MeshBuilder.CreateBox(\"Ending\", {width: boxW, height: boxH, depth: boxD},scene);\r\n    box.isVisible = false;\r\n\r\n    box.position.x = x;\r\n    box.position.y = y;\r\n    box.position.z = z;\r\n    //box.position = BABYLON.Vector3(4,-24,-850);    \r\n        \r\n    var Aggregate =new BABYLON.PhysicsAggregate(box, shapeBox1, { mass: 0 },scene);\r\n    Aggregate.shape.isTrigger =  true;\r\n\r\n    \r\n}\r\n\r\nfunction triggerRespawn(x,y,z){\r\n\r\n    const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n        new BABYLON.Vector3(0, 0, 0),        // center of the box\r\n        new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n        new BABYLON.Vector3(25, 2, 2000),      // dimensions of the box\r\n        scene                                // scene of the shape\r\n    );\r\n    \r\n\r\n\r\n    var boxW = x;\r\n    var boxH = y;\r\n    var boxD = z;\r\n\r\n    var box = BABYLON.MeshBuilder.CreateBox(\"Die\", {width: boxW, height: boxH, depth: boxD},scene);\r\n    box.isVisible = false;\r\n\r\n    box.position.x = 2;\r\n    box.position.y = -45;\r\n    box.position.z = -800;\r\n        \r\n        \r\n  \r\n    var Aggregate2 =new BABYLON.PhysicsAggregate(box, BABYLON.PhysicsShapeType.MESH, { mass: 0 }, scene);\r\n    Aggregate2.shape.isTrigger =  true;\r\n\r\n    \r\n}\r\n\r\n\r\n\r\nfunction eventHandler(hk,player){\r\n    \r\n    hk.onTriggerCollisionObservable.add((ev) => {\r\n        // console.log(ev);\r\n        console.log(ev.type, ':', ev.collider.transformNode.name, '-', ev.collidedAgainst.transformNode.name);\r\n        if(ev.collider.transformNode.name ==\"player1\" && ev.collidedAgainst.transformNode.name == \"Ending\"){\r\n            console.log(\"PLAYER 111111 PASSSSSS\")\r\n            sceneManager.setcountPlayer1()\r\n            console.log(\"COUNT_WIN PLAYER1:\"+sceneManager.winCountPlayer1)\r\n        }\r\n        if(ev.collider.transformNode.name ==\"player2\" && ev.collidedAgainst.transformNode.name == \"Ending\"){\r\n            console.log(\"PLAYER 2 PASSSSSS\")\r\n            sceneManager.setcountPlayer2()\r\n            console.log(\"COUNT_WIN PLAYER2\"+sceneManager.winCountPlayer2)\r\n        }\r\n        if(ev.collidedAgainst.transformNode.name ==\"tronc\"){\r\n                console.log(\"End OF the Game\")\r\n                reloadlevel();\r\n               \r\n                player = null;\r\n}      \r\n        if(ev.collidedAgainst.transformNode.name ==\"Ending\"){\r\n\r\n            console.log(\"COUNT_WIN PLAYER1:\"+sceneManager.winCountPlayer1+\"  COUNT_WIN PLAYER2\"+sceneManager.winCountPlayer2)\r\n           //console.log(\"YOU WINNNNNNN\")\r\n            killLevel();\r\n            loadNextLevel();\r\n            player = null;\r\n  \r\n\r\n        }\r\n        if(ev.collidedAgainst.transformNode.name ==\"Die\"){\r\n            console.log(\"YOU DIEEEEEEEEEE\");\r\n            value = \"death\";\r\n            reloadlevel();\r\n            player = null;\r\n           \r\n            //return \"death\";\r\n        }\r\n    });\r\n}\r\n\r\nfunction launch() {\r\n \r\n    \r\n    var camera = new BABYLON.FollowCamera(\"camera\", new BABYLON.Vector3(0, 5, -10), scene);\r\n    camera.cameraRotation = 0;\r\n    camera.viewport = new BABYLON.Viewport(0, 0, 0.5, 0.5);\r\n    \r\n    \r\n    var camera2 = new BABYLON.FollowCamera(\"camera2\", new BABYLON.Vector3(0, 5, -10), scene);\r\n    camera2.cameraRotation = 0;\r\n    camera2.viewport = new BABYLON.Viewport(0.5, 0, 0.5, 0.5); \r\n   \r\n    scene.activeCameras.push(camera);\r\n    scene.activeCameras.push(camera2);\r\n\r\n    //cam1\r\n    sceneData().then(playerMesh => {\r\n        let playerMesh2 = scene.getMeshByName(\"player2\");\r\n        console.log(playerMesh); // Utilisez playerMesh comme nécessaire\r\n        \r\n        camera.lockedTarget = playerMesh;\r\n        camera2.lockedTarget = playerMesh2;\r\n        \r\n    }).catch(error => {\r\n        console.error(error);\r\n    });\r\n\r\n    \r\n       \r\n \r\n    engine.runRenderLoop(function () {\r\n       //console.log(value)\r\n       scene.render();\r\n       \r\n     \r\n    });\r\n    \r\n   \r\n}\r\nfunction killLevel(player){\r\n    //scene.dispose();\r\n     \r\n    scene.meshes.forEach(function(mesh) {\r\n        mesh.dispose();\r\n    });\r\n   \r\n    scene.cameras.forEach(function(mesh) {\r\n        mesh.dispose();\r\n    });\r\n    // Supprimer toutes les lumières de la scène\r\n    scene.lights.forEach(function(light) {\r\n        light.dispose();\r\n    });\r\n  \r\n  \r\n    engine.stopRenderLoop();\r\n    hideControlUI();\r\n}\r\n\r\nfunction reloadlevel(){\r\n    let playerMesh = scene.getMeshByName(\"player1\");\r\n    let playerMesh2 = scene.getMeshByName(\"player2\");\r\n\r\n \r\n\r\n}\r\n\r\nfunction loadNextLevel(){\r\n    \r\n    sceneManager.launchLevel3();\r\n\r\n}\r\n\r\nfunction displayControlUI(){\r\n  \r\n   // Récupération de l'élément par son ID\r\n   var level1 = document.getElementById(\"level1\");\r\n\r\n   // Afficher l'élément\r\n   level1.style.display = \"block\";\r\n\r\n}\r\nfunction hideControlUI(){\r\n       // Récupération de l'élément par son ID\r\n   var level1 = document.getElementById(\"level1\");\r\n\r\n   // Afficher l'élément\r\n   level1.style.display = \"none\";\r\n\r\n}\r\n\r\nexport { name, scene, sceneData, launch,killLevel };\r\n","class CharacterController2 {\r\n    constructor(canvas, scene, engine, character1, input1, inputJump,animationGroup) {\r\n        this.setupKeyboardInputPlayer(canvas, engine, character1, input1, inputJump,animationGroup);\r\n    }\r\n\r\n    setupKeyboardInputPlayer(canvas, engine, character, input1, inputJump,animationGroup) {\r\n        this.keys = {};\r\n        let isKeyPressed = false;\r\n        let isKeyPressed2 = false;\r\n        // Écoute l'événement \"keydown\" (touche enfoncée) sur le canvas.\r\n        canvas.addEventListener('keydown', (event) => {\r\n            if (!this.keys[event.key]) {\r\n                this.keys[event.key] = true;\r\n\r\n                \r\n                // Vérifie si la touche est celle que vous souhaitez traiter\r\n                if (event.key === input1 && !isKeyPressed) {\r\n                    isKeyPressed = true;\r\n                    //console.log(\"Touche enfoncée, action effectuée\");\r\n                    \r\n                 \r\n                }\r\n                if (event.key === inputJump && !isKeyPressed2) {\r\n                    isKeyPressed2 = true;\r\n                    console.log(\"Touche enfoncée, action effectuée jump\");\r\n              \r\n                }\r\n            }\r\n        });\r\n\r\n        // Écoute l'événement \"keyup\" (touche relâchée) sur le canvas.\r\n        canvas.addEventListener('keyup', (event) => {\r\n            this.keys[event.key] = false;\r\n            \r\n            // Ensuite, planifiez la mise à false après une seconde\r\n            if (event.key === inputJump ) {\r\n                isKeyPressed2 = false;\r\n                console.log(\"Touche relâchée jump\");\r\n                // Ajoutez ici la logique pour arrêter le saut du personnage si nécessaire\r\n            \r\n            }\r\n\r\n            // Vérifie si la touche est celle que vous souhaitez traiter\r\n            if (event.key === input1) {\r\n                isKeyPressed = false;\r\n                //console.log(\"Touche relâchée\");\r\n            }\r\n        });\r\n\r\n        // Démarre la boucle de rendu du moteur Babylon.js.\r\n        engine.runRenderLoop(() => {\r\n            \r\n            if (isKeyPressed) {\r\n            \r\n                character.applyForce(new BABYLON.Vector3(0, 0, -50), new BABYLON.Vector3(0, 0, 0));\r\n    \r\n                character.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));\r\n               \r\n                isKeyPressed = false;\r\n                //console.log(  animationGroup)\r\n               //animationGroup[1].play();\r\n            }\r\n            \r\n            if (isKeyPressed2) {\r\n                character.applyForce(new BABYLON.Vector3(0, 200, 0), new BABYLON.Vector3(0, 0, 0));\r\n                character.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));\r\n                isKeyPressed2 = false;\r\n                //animationGroup[2].play();\r\n            }\r\n\r\n            character.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));\r\n        });\r\n    }\r\n}\r\n\r\nexport default CharacterController2;\r\n","\r\nimport CharacterController2 from './CharacterController2.js';\r\nvar engine2 = new BABYLON.Engine(canvas, true);\r\n\r\nvar canvas = document.getElementById(\"renderCanvas\");\r\n//var engine2 = new BABYLON.Engine(canvas2, true);\r\n\r\n//variables\r\n\r\n\r\n\r\nexport class PlayerLevel2 {\r\n\r\n    constructor(scene,engine,name,forward,jump,x,y,z) {\r\n        this.scene = scene;\r\n        this.engine = engine;\r\n        this.name = name;\r\n        this.boxBody ;\r\n        this.boxMesh;\r\n        this.animationGroups = [];\r\n        this.forward = forward\r\n        this.jump = jump;\r\n        \r\n        this.createPlayer(x,y,z);\r\n        this.enablePlayerControl(forward,jump);\r\n       // this.Character(x,y,z);\r\n     \r\n    }\r\n    \r\n\r\n    async createPlayer(x,y,z){\r\n\r\n        var boxW = 2;\r\n        var boxH = 2;\r\n        var boxD = 2;\r\n        \r\n        var box = BABYLON.MeshBuilder.CreateBox(this.name, {width: boxW, height: boxH, depth: boxD},this.scene);\r\n        this.boxMesh = box;\r\n        //ADD character disable box visibility \r\n        box.visibility = false;\r\n       //this.Character(x, y, z, box); \r\n\r\n\r\n\r\n        box.rotationQuaternion = BABYLON.Quaternion.Identity();\r\n        //box.position = new BABYLON.Vector3(0,5,0);\r\n        box.position = new BABYLON.Vector3(x,y,z);\r\n        var boxShape = new BABYLON.PhysicsShapeBox(new BABYLON.Vector3(0,0,0), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(boxW, boxH, boxD),this.scene);\r\n        var boxBody = new BABYLON.PhysicsBody(box, BABYLON.PhysicsMotionType.DYNAMIC, false, this.scene);\r\n        this.boxBody = boxBody;\r\n        boxBody.shape = boxShape;\r\n        boxBody.setMassProperties({mass : 1})\r\n    \r\n    \r\n        //add create material add tothe cube\r\n        var blueMaterial = new BABYLON.StandardMaterial(\"groundMaterial\", this.scene);\r\n        blueMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1); // Rouge doux\r\n        box.material = blueMaterial;\r\n       \r\n        \r\n        boxBody.setCollisionCallbackEnabled(true)\r\n        this.animationGroups = await this.Character(x, y, z, box);\r\n       //console.log(this.animationGroups);\r\n      \r\n    \r\n     \r\n     \r\n        \r\n    \r\n        //boxBody.applyForce()\r\n        //let control = new CharacterController2(canvas,scene,engine,boxBody,'s',' ');\r\n        //let control = new CharacterController2(canvas,scene,engine,boxBody,input1,inputJump);\r\n        return box;\r\n    }\r\n    \r\n  \r\n \r\n    enablePlayerControl(forward,jump){\r\n       let control = new CharacterController2(canvas,this.scene,this.engine,this.boxBody,forward,jump,this.animationGroups);\r\n    }\r\n    \r\n\r\n    destroyPlayer(){\r\n        \r\n        control = null;\r\n    }\r\n\r\n   \r\n    async Character(x, y, z, parent) {\r\n        let mesh; // Déclaration de mesh à un niveau supérieur pour qu'il soit accessible en dehors de la fonction de rappel\r\n    \r\n        const { meshes, animationGroups } = await BABYLON.SceneLoader.ImportMeshAsync(\"\", \"./models/character1_anim/\", \"animCharacter.glb\", this.scene);\r\n    \r\n        mesh = meshes[0]; // Assignation de meshes[0] à mesh\r\n        mesh.name = \"RUNNER\";\r\n        mesh.position = new BABYLON.Vector3(x, y - 1.05, z); // Positionne le modèle une fois chargé\r\n    \r\n        if (parent) {\r\n            mesh.setParent(parent); // Attacher le modèle au parent si spécifié\r\n        }\r\n        this.animationGroups.push(animationGroups) ;\r\n        // Vous pouvez ajouter des manipulations supplémentaires sur le mesh ici, comme l'échelle ou la rotation\r\n    \r\n        console.log(\"Chargement réussi Personnage\", mesh);\r\n        //gerer les animations\r\n        //console.log(\"ANIMATION GROUP :\"+animationGroups)\r\n  \r\n        //animationGroups[0].play();\r\n        //animationGroups[1].play();\r\n        //animationGroups[2].play();\r\n        //console.log(animationGroups[1])\r\n        await this.animGestionner(canvas,this.forward,this.jump,animationGroups)\r\n        \r\n    \r\n        return { animationGroups };\r\n    }\r\n\r\n    async animGestionner(canvas, input1, inputJump, animationGroup) {\r\n        this.keys = {};\r\n        let isKeyPressed = false;\r\n        let isKeyPressed2 = false;\r\n        // Écoute l'événement \"keydown\" (touche enfoncée) sur le canvas.\r\n        canvas.addEventListener('keydown', (event) => {\r\n            if (!this.keys[event.key]) {\r\n                this.keys[event.key] = true;\r\n                // Vérifie si la touche est celle que vous souhaitez traiter\r\n                if (event.key === input1 && !isKeyPressed) {\r\n                    isKeyPressed = true;\r\n                    //console.log(\"Touche enfoncée, action effectuée\");\r\n\r\n\r\n                }\r\n                if (event.key === inputJump && !isKeyPressed2) {\r\n                    isKeyPressed2 = true;\r\n                }\r\n            }\r\n        });\r\n\r\n        // Écoute l'événement \"keyup\" (touche relâchée) sur le canvas.\r\n        canvas.addEventListener('keyup', (event) => {\r\n            this.keys[event.key] = false;\r\n\r\n            // Ensuite, planifiez la mise à false après une seconde\r\n            if (event.key === inputJump) {\r\n                isKeyPressed2 = false;\r\n\r\n\r\n            }\r\n\r\n            // Vérifie si la touche est celle que vous souhaitez traiter\r\n            if (event.key === input1) {\r\n                isKeyPressed = false;\r\n\r\n            }\r\n        });\r\n\r\n        // Démarre la boucle de rendu du moteur Babylon.js.\r\n\r\n        engine2.runRenderLoop(() => {\r\n\r\n            if (isKeyPressed) {\r\n                isKeyPressed = false;\r\n                console.log(\"VOILA LE GROUPE :\" + animationGroup)\r\n                animationGroup[2].play();\r\n\r\n            }\r\n\r\n            if (isKeyPressed2) {\r\n\r\n                isKeyPressed2 = false;\r\n                //animationGroup[1].play();\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\nexport default PlayerLevel2;","var canvas = document.getElementById(\"renderCanvas\");\r\nvar engine = new BABYLON.Engine(canvas, true);\r\nvar scene = new BABYLON.Scene(engine);\r\nvar name = \"level3\";\r\n\r\nimport { CustomModels } from './CustomModels.js';\r\nimport CharacterController2 from './CharacterController2.js';\r\nimport * as sceneManager from './SceneManager.js';\r\nimport PlayerLevel2 from './PlayerLevel2.js';\r\n\r\nasync function getInitializedHavok() {\r\n    return await HavokPhysics();\r\n}\r\n\r\nasync function sceneData() {\r\n    //activer la physique sur la scene \r\n\r\n    const havokInstance = await HavokPhysics();\r\n \r\n\r\n    // pass the engine to the plugin\r\n    const hk = new BABYLON.HavokPlugin(true, havokInstance);\r\n\r\n\r\n    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), hk);\r\n    scene.collisionsEnabled = true;\r\n    \r\n   \r\n    // Configurez une caméra\r\n   \r\n    // Ajoutez une lumière\r\n    var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n\r\n    //var camera = new BABYLON.FreeCamera(\"camera\", new BABYLON.Vector3(0, 5, -10), scene);\r\n\r\n\r\n    // Créez un cube avec le matériau\r\n  \r\n   \r\n\r\n\r\n\r\n    //player2.position.x =0;\r\n    //player2.position.y =0;\r\n    //player2.position.z =0;\r\n\r\n    //var devcamera = new DevCamera(canvas, scene);\r\n    // Positionnez le cube où vous le souhaitez\r\n\r\n    triggerEnd(5,11,-620);\r\n    eventHandler(hk);\r\n\r\n    // Ajoutez l'événement de clic à la scène\r\n    scene.onPointerDown = function (evt, pickResult) {\r\n        onPointerDown(evt, pickResult);\r\n    };\r\n\r\n    var plane2 = new CustomModels(scene);\r\n    //plane2.CreatePlateform(0,0, -472,678);\r\n    plane2.CreatePlateformlevel2(-7,14, -265);\r\n    displayControlUI();\r\n\r\n\r\n     \r\n    let player1 = new PlayerLevel2(scene,engine,\"player1\",'s','f', 0,20,0);\r\n    let player2 = new PlayerLevel2(scene,engine,\"player2\",'k','m',-14,20,0);\r\n   //scene.debugLayer.show();\r\n\r\n}\r\n\r\nfunction launch() {\r\n   \r\n\r\n    \r\n   \r\n    //var camera = new BABYLON.FollowCamera(\"camera\", new BABYLON.Vector3(0, 5, -10), scene);\r\n    var camera = new BABYLON.FollowCamera(\"camera\", new BABYLON.Vector3(0, 5, -10), scene);\r\n    camera.cameraRotation = 0;\r\n    camera.viewport = new BABYLON.Viewport(0.5, 0, 0.5, 0.5);\r\n    \r\n    \r\n    var camera2 = new BABYLON.FollowCamera(\"camera2\", new BABYLON.Vector3(-3, 5, -10), scene);\r\n    camera2.cameraRotation = 0;\r\n    camera2.viewport = new BABYLON.Viewport(0, 0, 0.5, 0.5); \r\n   \r\n    //scene.activeCameras.push(camera);\r\n    scene.activeCameras.push(camera2);\r\n    scene.activeCameras.push(camera)\r\n\r\n\r\n\r\n  \r\n\r\n    \r\n\r\n\r\n\r\n    \r\n\r\n\r\n    //cam1\r\n    sceneData().then(playerMesh => {\r\n        let playerMesh2 = scene.getMeshByName(\"player2\");\r\n        console.log(\"MESH PLAYER2\"+playerMesh2); // Utilisez playerMesh comme nécessaire\r\n\r\n        let playerMesh1 = scene.getMeshByName(\"player1\");\r\n        //console.log(\"MESH PLAYER2\"+playerMesh); // Utilisez playerMesh comme nécessaire\r\n        \r\n        camera.lockedTarget = playerMesh2;\r\n        camera2.lockedTarget = playerMesh1;\r\n        \r\n    }).catch(error => {\r\n        console.error(error);\r\n    });\r\n\r\n\r\n    engine.runRenderLoop(function () {\r\n        scene.render();\r\n    });\r\n}\r\n\r\n// Fonction appelée lorsqu'un clic est détecté\r\nfunction onPointerDown(evt, pickResult) {\r\n    if (pickResult.hit) {\r\n        // Votre code d'interaction ici, par exemple, changez la couleur de l'objet\r\n        if(pickResult.pickedMesh.name ==\"player\"){\r\n\r\n            pickResult.pickedMesh.material.diffuseColor = new BABYLON.Color3(0, 1, 0); // Vert\r\n        }\r\n       \r\n    }\r\n}\r\n\r\n\r\n\r\nfunction catchPlayer(){\r\n    \r\n}\r\n\r\nfunction createPlayer(x,y,z , input1,inputJump){\r\n\r\n    var boxW = 2;\r\n    var boxH = 2;\r\n    var boxD = 2;\r\n    \r\n    var box = BABYLON.MeshBuilder.CreateBox(\"player\", {width: boxW, height: boxH, depth: boxD},scene);\r\n   \r\n    box.rotationQuaternion = BABYLON.Quaternion.Identity();\r\n    //box.position = new BABYLON.Vector3(0,5,0);\r\n    box.position = new BABYLON.Vector3(x,y,z);\r\n    var boxShape = new BABYLON.PhysicsShapeBox(new BABYLON.Vector3(0,0,0), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(boxW, boxH, boxD), scene);\r\n    var boxBody = new BABYLON.PhysicsBody(box, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);\r\n\r\n    boxBody.shape = boxShape;\r\n    boxBody.setMassProperties({mass : 1})\r\n\r\n\r\n    //add create material add tothe cube\r\n    var blueMaterial = new BABYLON.StandardMaterial(\"groundMaterial\", scene);\r\n    blueMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1); // Rouge doux\r\n    box.material = blueMaterial;\r\n   \r\n    \r\n    boxBody.setCollisionCallbackEnabled(true)\r\n  \r\n   \r\n    \r\n \r\n\r\n \r\n \r\n    \r\n\r\n    //boxBody.applyForce()\r\n    //let control = new CharacterController2(canvas,scene,engine,boxBody,'s',' ');\r\n    let control = new CharacterController2(canvas,scene,engine,boxBody,input1,inputJump);\r\n    return box;\r\n}\r\n\r\n\r\nfunction getScene() {\r\n    return scene;\r\n}\r\n\r\n\r\nfunction triggerEnd(x,y,z){\r\n\r\n    const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n        new BABYLON.Vector3(0, 0, 0),        // center of the box\r\n        new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n        new BABYLON.Vector3(60, 2, 2000),      // dimensions of the box\r\n        scene                                // scene of the shape\r\n    );\r\n    \r\n\r\n\r\n    var boxW = 40;\r\n    var boxH = 40;\r\n    var boxD = 40;\r\n\r\n    var box = BABYLON.MeshBuilder.CreateBox(\"Ending\", {width: boxW, height: boxH, depth: boxD},scene);\r\n    box.isVisible = false;\r\n\r\n    box.position.x = x;\r\n    box.position.y = y;\r\n    box.position.z = z;\r\n        \r\n        \r\n  \r\n    var Aggregate2 =new BABYLON.PhysicsAggregate(box, BABYLON.PhysicsShapeType.MESH, { mass: 0 }, scene);\r\n    Aggregate2.shape.isTrigger =  true;\r\n\r\n    \r\n}\r\n\r\n\r\nfunction eventHandler(hk){\r\n    \r\n    hk.onTriggerCollisionObservable.add((ev) => {\r\n        // console.log(ev);\r\n        console.log(ev.type, ':', ev.collider.transformNode.name, '-', ev.collidedAgainst.transformNode.name);\r\n\r\n        if(ev.collider.transformNode.name ==\"player1\" && ev.collidedAgainst.transformNode.name == \"Ending\"){\r\n            console.log(\"PLAYER 111111 PASSSSSS\")\r\n            sceneManager.setcountPlayer1()\r\n            console.log(\"COUNT_WIN PLAYER1:\"+sceneManager.winCountPlayer1)\r\n        }\r\n        if(ev.collider.transformNode.name ==\"player2\" && ev.collidedAgainst.transformNode.name == \"Ending\"){\r\n            console.log(\"PLAYER 2 PASSSSSS\")\r\n            sceneManager.setcountPlayer2()\r\n            console.log(\"COUNT_WIN PLAYER2\"+sceneManager.winCountPlayer2)\r\n        }\r\n\r\n        if(ev.collidedAgainst.transformNode.name ==\"Ending\"){\r\n   \r\n   \r\n\r\n            //console.log(\"YOU WINNNNNNN\")\r\n            killLevel();\r\n            loadNextLevel();\r\n\r\n        }\r\n      \r\n    });\r\n}\r\n\r\nfunction loadNextLevel(){\r\n    \r\n    sceneManager.launchLevel4();\r\n\r\n}\r\nfunction killLevel(){\r\n    //scene.dispose();\r\n     \r\n    scene.meshes.forEach(function(mesh) {\r\n        mesh.dispose();\r\n    });\r\n   \r\n    scene.cameras.forEach(function(mesh) {\r\n        mesh.dispose();\r\n    });\r\n    // Supprimer toutes les lumières de la scène\r\n    scene.lights.forEach(function(light) {\r\n        light.dispose();\r\n    });\r\n\r\n    \r\n    engine.stopRenderLoop();\r\n    hideControlUI();\r\n}\r\n\r\nfunction displayControlUI(){\r\n  \r\n    // Récupération de l'élément par son ID\r\n    var level1 = document.getElementById(\"level2\");\r\n \r\n    // Afficher l'élément\r\n    level1.style.display = \"block\";\r\n \r\n }\r\n function hideControlUI(){\r\n        // Récupération de l'élément par son ID\r\n    var level1 = document.getElementById(\"level2\");\r\n \r\n    // Afficher l'élément\r\n    level1.style.display = \"none\";\r\n \r\n }\r\n\r\nexport { name, scene, sceneData, launch };\r\n","class CharacterController2 {\r\n    constructor(canvas, engine, character1, inputLeft, inputRight,inputJump,inputLaunch) {\r\n        this.destroyed = false;\r\n        this.action = false;\r\n        this.setupKeyboardInputPlayer(canvas, engine, character1, inputLeft, inputRight,inputJump,inputLaunch);\r\n    }\r\n\r\n    setupKeyboardInputPlayer(canvas, engine, character, input1,input2, inputJump,inputLaunch) {\r\n        this.keys = {};\r\n        let isKeyPressed = false;\r\n        let isKeyPressed2 = false;\r\n        // Écoute l'événement \"keydown\" (touche enfoncée) sur le canvas.\r\n        canvas.addEventListener('keydown', (event) => {\r\n            if (!this.keys[event.key]) {\r\n                this.keys[event.key] = true;\r\n         \r\n             \r\n            }\r\n        });\r\n\r\n        // Écoute l'événement \"keyup\" (touche relâchée) sur le canvas.\r\n        canvas.addEventListener('keyup', (event) => {\r\n            this.keys[event.key] = false;\r\n       \r\n        });\r\n\r\n        // Démarre la boucle de rendu du moteur Babylon.js.\r\n        engine.runRenderLoop(() => {\r\n          \r\n            if(!this.destroyed){\r\n                if (this.keys[input1] ) {\r\n                    //console.log('Touche gauche enfoncée');\r\n                    character.applyForce(new BABYLON.Vector3(5*2, 0, 0), new BABYLON.Vector3(0, 0, 0));\r\n                    character.setAngularVelocity(BABYLON.Vector3.ZeroReadOnly);\r\n            \r\n                }\r\n\r\n                if (this.keys[input2] ) {\r\n                    //console.log('Touche Droite enfoncée');\r\n                    character.applyForce(new BABYLON.Vector3(-5*2, 0, 0), new BABYLON.Vector3(0, 0, 0));\r\n                    character.setAngularVelocity(BABYLON.Vector3.ZeroReadOnly);\r\n        \r\n                }\r\n\r\n         \r\n                if (this.keys[inputLaunch] && !this.action) {\r\n                    //console.log('Touche LAUNCH enfoncée');\r\n                    this.action = true;\r\n                    character.applyForce(new BABYLON.Vector3(0, 0, 700*4), new BABYLON.Vector3(0, 0, 0));\r\n                    //character.setAngularVelocity(BABYLON.Vector3.ZeroReadOnly);\r\n        \r\n                }\r\n\r\n                //character.setAngularVelocity(BABYLON.Vector3.ZeroReadOnly);\r\n            }\r\n        });\r\n\r\n       \r\n    }\r\n\r\n\r\n    destroy() {\r\n     \r\n        this.destroyed = true;\r\n\r\n        // Libérez les références aux objets\r\n        this.canvas = null;\r\n        this.engine = null;\r\n\r\n        //this.character1.dispose();\r\n        this.character1 = null;\r\n        this.inputLeft = null;\r\n        this.inputRight = null;\r\n        this.inputJump = null;\r\n        this.inputLaunch = null;\r\n\r\n        // Réinitialisez ou supprimez d'autres ressources si nécessaire\r\n    }\r\n    isUpperCase(input,key) {\r\n        return key === input.toUpperCase();\r\n    }\r\n    getLastKeyPressed() {\r\n        return this.lastKeyPressed; // Fonction pour récupérer la dernière touche enfoncée\r\n    }\r\n\r\n    \r\n}\r\n\r\nexport default CharacterController2;\r\n","\r\nimport CharacterController3 from './CharacterController3.js';\r\n\r\nvar canvas2 = document.getElementById(\"renderCanvas\");\r\n//var engine2 = new BABYLON.Engine(canvas2, true);\r\n\r\n//variables\r\n\r\n\r\n\r\nexport class PlayerLevel3 {\r\n\r\n    constructor(scene,engine,name,left,right,jump,action,x,y,z) {\r\n        this.control;\r\n        this.scene = scene;\r\n        this.engine = engine;\r\n        this.name= name;\r\n        this.boxBody ;\r\n        this.sphereBody;\r\n        this.box;\r\n        this.rayHelper;\r\n        //this.testPlayer(scene,engine,name,x,y,z);\r\n      \r\n        this.shootBall(left,right,jump,action,x,y,z);\r\n    \r\n        this.enablePlayerControl(left,right,jump,action);\r\n\r\n        \r\n        //this.raycast();\r\n     \r\n    }\r\n    \r\n\r\n    testPlayer(scene,engine,name,x,y,z){\r\n        var boxW = 2;\r\n        var boxH = 2;\r\n        var boxD = 2;\r\n        \r\n       \r\n        var box = BABYLON.MeshBuilder.CreateBox(name, {width: boxW, height: boxH, depth: boxD},scene);\r\n        this.box =box;\r\n   \r\n        box.rotationQuaternion = BABYLON.Quaternion.Identity();\r\n        //box.position = new BABYLON.Vector3(0,5,0);\r\n        box.position = new BABYLON.Vector3(x,y,z);\r\n        var boxShape = new BABYLON.PhysicsShapeBox(new BABYLON.Vector3(0,0,0), BABYLON.Quaternion.Identity(), new BABYLON.Vector3(boxW, boxH, boxD), scene);\r\n        var boxBody = new BABYLON.PhysicsBody(box, BABYLON.PhysicsMotionType.DYNAMIC, false, scene);\r\n    \r\n        boxBody.shape = boxShape;\r\n        boxBody.setMassProperties({mass : 1})\r\n    \r\n    \r\n        //add create material add tothe cube\r\n        var blueMaterial = new BABYLON.StandardMaterial(\"groundMaterial\", scene);\r\n        blueMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1); // Rouge doux\r\n        box.material = blueMaterial;\r\n       \r\n        \r\n        boxBody.setCollisionCallbackEnabled(true)\r\n      \r\n       \r\n        this.boxBody = boxBody;\r\n        \r\n    \r\n     \r\n     \r\n        \r\n    \r\n\r\n      \r\n        \r\n    }\r\n  \r\n \r\n    enablePlayerControl(inputLeft,inputRight,jump,action){\r\n       //let control = new CharacterController(canvas2,this.engine,this.boxBody,forward,backward,left,right);\r\n        let control2 = new CharacterController3(canvas2,this.engine,this.sphereBody, inputRight,inputLeft,jump,action);\r\n        this.control = control2;\r\n     \r\n      \r\n    }\r\n\r\n    raycast() {\r\n        // Get the player mesh by name\r\n        var playerMesh = this.scene.getMeshByName(this.name);\r\n        // Ensure the player mesh exists\r\n        if (!playerMesh) {\r\n            console.error(\"Player mesh not found\");\r\n            return;\r\n        }\r\n        // Get the player's position\r\n        var rayOrigin = playerMesh.position;\r\n        // Set the ray direction along the positive Z-axis\r\n        var rayDirection = new BABYLON.Vector3(0, 0, 1);\r\n        // Set the ray length\r\n        var rayLength = 50;\r\n        // Calculate the destination point of the ray\r\n        var rayDestination = rayOrigin.add(rayDirection.scale(rayLength));\r\n        // Create the ray\r\n        var ray = new BABYLON.Ray(rayOrigin, rayDirection, rayLength);\r\n        // Create a ray helper for visualization (optional)\r\n        var rayHelper = new BABYLON.RayHelper(ray);\r\n        rayHelper.show(this.scene, new BABYLON.Color3(0.9, 0, 0));\r\n        // Perform raycasting or any other actions with the ray\r\n        // Example: Check if the ray intersects with a mesh\r\n        var hit = this.scene.pickWithRay(ray);\r\n        \r\n        this.rayHelper = rayHelper;\r\n        //rayHelper.hide();\r\n\r\n        /*\r\n        if (hit.pickedMesh) {\r\n            console.log(\"Ray hits:\", hit.pickedMesh.name);\r\n            // Do something with the intersected mesh\r\n        }*/\r\n    }\r\n\r\n    shootBall(left,right,jump,action,x,y,z){\r\n        let segments = 16;\r\n        let diameter = 2;\r\n\r\n        const sphere = BABYLON.MeshBuilder.CreateSphere(this.name, { segments, diameter }, this.scene);\r\n        sphere.position = new BABYLON.Vector3(x,y,z);\r\n\r\n       \r\n        var sphereShape = new BABYLON.PhysicsShapeSphere(new BABYLON.Vector3(0,0,0),diameter-1,this.scene);\r\n        var sphereBody = new BABYLON.PhysicsBody(sphere, BABYLON.PhysicsMotionType.DYNAMIC, false, this.scene);\r\n        sphereBody.shape = sphereShape;\r\n        sphereBody.setMassProperties({mass : 2});\r\n        //sphereBody.setCollisionCallbackEnabled(true);\r\n       \r\n        \r\n        this.sphereBody = sphereBody;\r\n        //this.sphereBody.dispose();\r\n\r\n    }\r\n    disableThisObject(){\r\n        //delete this.control;\r\n        this.control.destroy();\r\n        this.control = null;\r\n        \r\n        //this.sphereBody.dispose();\r\n       \r\n    }\r\n    instanciate(){\r\n\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n}\r\nexport default PlayerLevel3;","\r\n\r\nexport class BowlingPin {\r\n\r\n    constructor(scene,x,y,z) {\r\n       \r\n        this.scene = scene;\r\n       \r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n\r\n        this.mesh;\r\n        this.Aggregate;\r\n        this.meshIdPromise = this.createBowlingPin();\r\n    }\r\n    \r\n    createBowlingPin(){\r\n\r\n        return new Promise((resolve) => {\r\n\r\n            BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Bowling Pin.glb\", this.scene, (meshes) => {\r\n\r\n             \r\n\r\n                const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n                    new BABYLON.Vector3(0, 0, 0),        // center of the box\r\n                    new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n                    new BABYLON.Vector3(0.5, 1.2, 0.5),      // dimensions of the box\r\n                    this.scene                                // scene of the shape\r\n                );\r\n        \r\n\r\n                let boxKid = BABYLON.MeshBuilder.CreateBox(\"Pintrigger\");\r\n                //boxKid.isVisible = false;\r\n\r\n                //console.log(\"Chargement réussi Pin\", meshes);\r\n            \r\n                let mesh = meshes[0];\r\n                mesh.scaling._z =  mesh.scaling._z *-1;\r\n                mesh.name =\"Pin\"\r\n\r\n  \r\n            \r\n        \r\n                mesh.position = new BABYLON.Vector3(this.x, this.y, this.z); // Positionne l'objet\r\n            \r\n\r\n            \r\n                var Aggregate =new BABYLON.PhysicsAggregate(mesh, shapeBox1, { mass: 0.1 }, this.scene);\r\n                Aggregate.body.setCollisionCallbackEnabled(true);\r\n                this.Aggregate = Aggregate;\r\n                this.mesh = mesh;\r\n               \r\n                const meshId = mesh.uniqueId;\r\n                resolve(meshId);\r\n\r\n            }, undefined, undefined, \".glb\");\r\n        })\r\n\r\n    }\r\n  \r\n    \r\n    async getMeshId(){\r\n         return await this.meshIdPromise;\r\n    }\r\n \r\n   \r\n    disableThisObject(){\r\n        this.Aggregate.body.setCollisionCallbackEnabled(false);\r\n        this.Aggregate.body.dispose();\r\n        //this.mesh.dispose();\r\n       \r\n    }\r\n    isPinUp() {\r\n        // Récupérer la rotation de la quille\r\n        const rotation = this.mesh.rotationQuaternion.toEulerAngles();\r\n\r\n        // Définir un seuil pour la rotation, en dessous duquel la quille est considérée comme renversée\r\n        const threshold = 0.1; // À ajuster selon vos besoins\r\n\r\n        // Vérifier si la rotation autour de l'axe X (ou un autre axe selon votre modèle) dépasse le seuil\r\n        const isUp = Math.abs(rotation.x) < threshold;\r\n\r\n        return isUp;\r\n    }\r\n    \r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n}\r\nexport default BowlingPin;","var canvas = document.getElementById(\"renderCanvas\");\r\nvar engine = new BABYLON.Engine(canvas, true);\r\nvar scene = new BABYLON.Scene(engine);\r\nvar name = \"level4\";\r\nlet advancedTexture ;\r\n\r\nimport { CustomModels } from './CustomModels.js';\r\nimport CharacterController3 from './CharacterController3.js';\r\nimport PlayerLevel3 from './PlayerLevel3.js';\r\nimport BowlingPin from './BowlingPin.js';\r\nimport * as sceneManager from './SceneManager.js';\r\n\r\nlet player1;\r\nlet player2;\r\n\r\nlet countPlayer1 =0;\r\nlet countPlayer2 =0;\r\n\r\n\r\n\r\nasync function sceneData() {\r\n    //activer la physique sur la scene \r\n\r\n    const havokInstance = await HavokPhysics();\r\n\r\n\r\n    // pass the engine to the plugin\r\n    const hk = new BABYLON.HavokPlugin(true, havokInstance);\r\n\r\n\r\n    scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), hk);\r\n    scene.collisionsEnabled = true;\r\n       \r\n    \r\n    \r\n    // Ajoutez une lumière\r\n    var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n\r\n   \r\n\r\n    var model = new CustomModels(scene);\r\n    \r\n    var listeQuilles1 = [];\r\n\r\n    \r\n\r\n    let add =13 ;\r\n    var listeQuilles2 = [];\r\n   \r\n    \r\n    \r\n\r\n\r\n \r\n   // console.log(countPlayer1);\r\n     player1 = new PlayerLevel3(scene,engine,\"player1\",'q','d','s',' ',0,8,-8);\r\n     player2 = new PlayerLevel3(scene,engine,\"player2\",'ArrowLeft','ArrowRight','i','Enter',25,8,-8);\r\n\r\n     //let pin = new BowlingPin(scene,0,2,19.397);\r\n    \r\n   \r\n    let ball1 = scene.getMeshByName(\"player1\");\r\n    \r\n    displayControlUI();\r\n    //CreateBowlingBall(0,6,0);\r\n\r\n    eventHandler(hk,player1,player2);\r\n\r\n   // model.CreatePlateform_Scene4();\r\n    model.CreateBowlingPlatform();\r\n    listeQuilles1 =  addQuille(listeQuilles1,0,0,-8);\r\n    listeQuilles2 =  addQuille(listeQuilles2,25,0,-8);\r\n\r\n    testSearch(listeQuilles1,countPlayer1,\"player1\");\r\n    testSearch2(listeQuilles2,countPlayer2,\"player2\");\r\n\r\n    \r\n        \r\n\r\n    let ball = scene.getMeshByName(\"ball\");\r\n    \r\n    \r\n\r\n  \r\n    /*\r\n    //trigger Player1\r\n    triggerRespawn(0,2,97.43,30, 30, 10);\r\n    triggerRespawn(7.5,2,48,1, 30,90);\r\n    triggerRespawn(-7.5,2,48,1, 30,90);\r\n\r\n    //trigger Player2\r\n    triggerRespawn(30,2,97.43,30, 30, 10);\r\n    triggerRespawn(20,2,48,1, 30,90);\r\n    triggerRespawn(35.5,2,48,1, 30,90);*/\r\n\r\n    respawnPlayerInput(player1,player2);\r\n\r\n    \r\n\r\n\r\n\r\n}\r\n\r\nfunction launch() {\r\n      \r\n    var camera = new BABYLON.FreeCamera(\"camera\", new BABYLON.Vector3(0, 5, -22), scene);\r\n    camera.inertia = 0;\r\n    camera.angularSensibility = 0;\r\n    camera.detachControl(canvas);\r\n    camera.cameraRotation = 0;\r\n    scene.activeCameras.push(camera);\r\n    \r\n    camera.viewport = new BABYLON.Viewport(0, 0, 0.5, 1);\r\n    scene.activeCameras.push(camera);\r\n\r\n\r\n    var camera2 = new BABYLON.FreeCamera(\"camera\", new BABYLON.Vector3(25, 4, -23), scene);\r\n    camera2.inertia = 0;\r\n    camera2.angularSensibility = 0;\r\n    camera2.detachControl(canvas);\r\n    camera2.cameraRotation = 0;\r\n    scene.activeCameras.push(camera2);\r\n    camera2.viewport = new BABYLON.Viewport(0.5,0 , 0.5, 1);\r\n    scene.activeCameras.push(camera2);\r\n    \r\n   \r\n\r\n \r\n\r\n    sceneData();\r\n  \r\n\r\n    let playerMesh = scene.getMeshByName(\"player1\");\r\n    let playerMesh2 = scene.getMeshByName(\"player2\");\r\n    //console.log(playerMesh2);\r\n    //console.log(playerMesh); // Utilisez playerMesh comme nécessaire\r\n    \r\n    camera.lockedTarget = playerMesh;\r\n    //camera2.lockedTarget = playerMesh2;\r\n\r\n    engine.runRenderLoop(function () {\r\n\r\n        scene.render();\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\nfunction CreateBowlingBall(x, y, z) {\r\n    let tree;\r\n    let boundingBox;\r\n    let tronc;\r\n    var mesh \r\n    BABYLON.SceneLoader.ImportMesh(\"\", \"./models/\", \"Spiky Ball.glb\", scene, (meshes) => {\r\n        console.log(\"Chargement réussi ball\", meshes);\r\n    \r\n        mesh = meshes[0];\r\n      \r\n        mesh.name =\"ball\"\r\n        \r\n    \r\n\r\n        mesh.position = new BABYLON.Vector3(x, y, z); // Positionne l'arbre aux \r\n        \r\n        //var troncAggregate =new BABYLON.PhysicsAggregate(mesh, BABYLON.PhysicsShapeType.SPHERE, { mass: 0 }, this.scene);\r\n     \r\n    \r\n    }, undefined, undefined, \".glb\");\r\n\r\n\r\n\r\n    return {mesh};\r\n}\r\n\r\n\r\nfunction triggerRespawn(x,y,z,sizeX,sizeY,sizeZ){\r\n\r\n    const shapeBox1 = new BABYLON.PhysicsShapeBox(\r\n        new BABYLON.Vector3(0, 0, 0),        // center of the box\r\n        new BABYLON.Quaternion(0, 0, 0, 1),  // rotation of the box\r\n        new BABYLON.Vector3(sizeX,sizeY,sizeZ),      // dimensions of the box\r\n        scene                                // scene of the shape\r\n    );\r\n    \r\n\r\n    //let RainBowMesh = scene.getMeshByName(\"RainBow\");\r\n\r\n    var boxW = 2;\r\n    var boxH = 2;\r\n    var boxD = 2;\r\n\r\n    var box = BABYLON.MeshBuilder.CreateBox(\"Respawn\", {width: boxW, height: boxH, depth: boxD},scene);\r\n    box.isVisible = false;\r\n\r\n    box.position.x = x;\r\n    box.position.y = y;\r\n    box.position.z = z;\r\n    //box.position = BABYLON.Vector3(4,-24,-850);    \r\n        \r\n    var Aggregate =new BABYLON.PhysicsAggregate(box, shapeBox1, { mass: 0 },scene);\r\n    Aggregate.shape.isTrigger =  true;\r\n    \r\n\r\n    \r\n    //Aggregate.dispose();\r\n    \r\n}\r\n\r\nfunction eventHandler(hk,player1,player2){\r\n\r\n    \r\n    hk.onTriggerCollisionObservable.add((ev) => {\r\n        // console.log(ev);\r\n        console.log(ev.type, ':', ev.collider.transformNode.name, '-', ev.collidedAgainst.transformNode.name);\r\n       \r\n        if(ev.collidedAgainst.transformNode.name ==\"Ending\"){\r\n            console.log(\"YOU WINNNNNNN\")\r\n            //killLevel();\r\n            //loadNextLevel();\r\n            player1 = null;\r\n  \r\n\r\n        }\r\n\r\n        if(ev.collidedAgainst.transformNode.name ==\"Respawn\" && ( ev.collider.transformNode.name == \"player1\" || ev.collider.transformNode.name == \"player2\" ) ){\r\n            console.log(\"YOU RESPAWNWNNN\");\r\n\r\n            if(ev.collider.transformNode.name == \"player1\"){\r\n                let ball1 = scene.getMeshByName(\"player1\");\r\n         \r\n                player1.disableThisObject();\r\n                //player1 = null;\r\n                ball1.dispose();\r\n                \r\n                player1 = new PlayerLevel3(scene,engine,\"player1\",'q','d','s',' ',-5,5,0);\r\n            \r\n     \r\n            }else{\r\n                let ball2 = scene.getMeshByName(\"player2\");\r\n                player2.disableThisObject();\r\n                //player2 = null;\r\n                ball2.dispose()\r\n\r\n                player2= new PlayerLevel3(scene,engine,\"player2\",'j','l','i','Enter',28,5,0);\r\n              \r\n            }\r\n          \r\n         \r\n\r\n            \r\n          \r\n        }\r\n     \r\n    });\r\n\r\n   //WinParty\r\n\r\n   \r\n}\r\n\r\n\r\n\r\n\r\nfunction pinsCount(hk){\r\n\r\n    hk.onCollisionObservable.add((ev) => {\r\n        //console.log(ev.type);\r\n        //console.log(ev.type, ':', ev.collider.transformNode.name, '-', ev.collidedAgainst.transformNode.name);\r\n       //check if Pin is collided add count to counter of the player\r\n   \r\n       if(ev.collidedAgainst.transformNode.name ==\"Pin\" ){\r\n            //console.log(\"YOU collide a pin\");\r\n            let uniqueId =ev.collidedAgainst.transformNode.uniqueId;\r\n            //console.log(ev.collidedAgainst.transformNode.uniqueId);\r\n            //list.push();\r\n            if(ev.collider.transformNode.name == \"player2\"){\r\n\r\n                //console.log(\"player1 IS ON THE PLACE\")\r\n\r\n                testSearch(uniqueId);\r\n              \r\n                countPlayer1++;\r\n                //console.log(countPlayer1);\r\n                \r\n            }\r\n      \r\n        }\r\n});\r\n\r\n}\r\n\r\nasync function testSearch(listeQuilles1,countPlayer,playerText){\r\n\r\n \r\n    engine.runRenderLoop(async () => {\r\n\r\n        for(let i=0;i<listeQuilles1.length; i++){\r\n            const meshIdQuille = await listeQuilles1[i].getMeshId();\r\n            const quille =  listeQuilles1[i];\r\n            //console.log(meshIdQuille);\r\n            /*\r\n            if(meshIdQuille == id){\r\n                \r\n                quille.disableThisObject();\r\n            \r\n            }*/\r\n            if(!quille.isPinUp()){\r\n                countPlayer1++;\r\n                \r\n                listeQuilles1.splice(i, 1);\r\n\r\n                // Décrémenter i pour compenser la suppression de l'élément\r\n                i--;\r\n                    \r\n            };\r\n        }\r\n        //console.log(\"compteur \"+playerText+\" \" +countPlayer1);\r\n        document.getElementById(\"pin1\").innerHTML = countPlayer1 + \"/93 PINS\";\r\n\r\n  \r\n        if(countPlayer1 >=93){\r\n            sceneManager.setcountPlayer1()\r\n            console.log(\"PLAYER1:\"+sceneManager.winCountPlayer1)\r\n            console.log(\"PLAYER2:\"+sceneManager.winCountPlayer2)\r\n        }\r\n        \r\n      \r\n   \r\n        if(countPlayer1 >= 93 ||countPlayer2 >= 93){\r\n            killLevel();\r\n            loadNextLevel();\r\n        }\r\n\r\n        // Utiliser setInterval pour appeler la fonction de mise à jour à intervalles réguliers (par exemple, toutes les 1000 millisecondes)\r\n        //setInterval(updateCountPins, 1000); //\r\n        \r\n\r\n\r\n    })\r\n   \r\n  \r\n    \r\n \r\n}\r\nasync function testSearch2(listeQuilles1,countPlayer,playerText){\r\n\r\n \r\n    engine.runRenderLoop(async () => {\r\n\r\n        for(let i=0;i<listeQuilles1.length; i++){\r\n            const meshIdQuille = await listeQuilles1[i].getMeshId();\r\n            const quille =  listeQuilles1[i];\r\n            //console.log(meshIdQuille);\r\n            /*\r\n            if(meshIdQuille == id){\r\n                \r\n                quille.disableThisObject();\r\n            \r\n            }*/\r\n            if(!quille.isPinUp()){\r\n                countPlayer2++;\r\n                \r\n                listeQuilles1.splice(i, 1);\r\n\r\n                // Décrémenter i pour compenser la suppression de l'élément\r\n                i--;\r\n                    \r\n            };\r\n        }\r\n        //console.log(\"compteur \"+playerText+\" \" +countPlayer2);\r\n\r\n\r\n        document.getElementById(\"pin2\").innerHTML = countPlayer2 + \"/93 PINS\";\r\n  \r\n     \r\n        if(countPlayer2 >92){\r\n            sceneManager.setcountPlayer2()\r\n            console.log(\"PLAYER1:\"+sceneManager.winCountPlayer1)\r\n            console.log(\"PLAYER2\"+sceneManager.winCountPlayer2)\r\n\r\n        }\r\n   \r\n        if(countPlayer1 >= 93 ||countPlayer2 >= 93){\r\n            killLevel();\r\n            loadNextLevel();\r\n        }\r\n\r\n        // Utiliser setInterval pour appeler la fonction de mise à jour à intervalles réguliers (par exemple, toutes les 1000 millisecondes)\r\n        //setInterval(updateCountPins, 1000); //\r\n        \r\n\r\n\r\n    })\r\n   \r\n  \r\n    \r\n \r\n}\r\n\r\n\r\n\r\nfunction addQuille( listeQuilles1,x,y,z){\r\n\r\n\r\n    listeQuilles1 = [\r\n        //-3\r\n        new BowlingPin(scene, 0.25+x, 2+y,21+z),\r\n        //-2\r\n             \r\n        //new BowlingPin(scene, 0, 2, 21.5),\r\n       \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y,21.5+z),\r\n        new BowlingPin(scene, 0.50+x, 2+y,21.5+z),\r\n        //new BowlingPin(scene, 0.60, 2,21.5),\r\n      \r\n\r\n\r\n        //-1\r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 22+z),\r\n       \r\n        \r\n        new BowlingPin(scene, 0.25+x, 2+y, 22+z),\r\n        new BowlingPin(scene, 0.60+x, 2+y,22+z),\r\n        \r\n      \r\n\r\n\r\n        //0\r\n        new BowlingPin(scene, -0.5+x, 2+y, 22.5+z),\r\n       \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 22.5+z),\r\n        new BowlingPin(scene, 0.5+x, 2+y,22.5+z),\r\n        new BowlingPin(scene, 1+x, 2+y,22.5+z),\r\n        \r\n        //1\r\n        new BowlingPin(scene, -0.5+x, 2+y, 23+z),\r\n        new BowlingPin(scene, -1+x, 2+y, 23+z),\r\n       \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 23+z),\r\n        new BowlingPin(scene, 0.5+x, 2+y,23+z),\r\n        new BowlingPin(scene, 1+x, 2+y,23+z),\r\n        new BowlingPin(scene, 1.5+x, 2+y,23+z),\r\n   \r\n        //2\r\n        new BowlingPin(scene, -0.5+x, 2+y, 23.5+z),\r\n        new BowlingPin(scene, -1+x, 2+y, 23.5+z),\r\n        new BowlingPin(scene, -1.5+x, 2+y, 23.5+z),\r\n\r\n   \r\n      \r\n      \r\n        \r\n \r\n                \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 23.5+z),\r\n        new BowlingPin(scene, 0.5+x, 2+y,23.5+z),\r\n        new BowlingPin(scene, 1+x, 2+y,23.5+z),\r\n        new BowlingPin(scene, 1.5+x, 2+y,23.5+z),\r\n        new BowlingPin(scene, 2+x, 2+y,23.5+z),\r\n      \r\n        \r\n        //3\r\n        new BowlingPin(scene, -0.5+x, 2+y, 24+z),\r\n        new BowlingPin(scene, -1+x, 2+y, 24+z),\r\n        new BowlingPin(scene, -1.5+x, 2+y, 24+z),\r\n        new BowlingPin(scene, -2+x, 2+y, 24+z),\r\n   \r\n      \r\n      \r\n        \r\n \r\n                \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 24+z),\r\n        new BowlingPin(scene, 0.5+x, 2+y, 24+z),\r\n        new BowlingPin(scene, 1+x, 2+y, 24+z),\r\n        new BowlingPin(scene, 1.5+x, 2+y, 24+z),\r\n        new BowlingPin(scene, 2+x, 2+y,24+z),\r\n        new BowlingPin(scene, 2.5+x, 2+y, 24+z),\r\n        \r\n        //4\r\n        new BowlingPin(scene, -0.5+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, -1+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, -1.5+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, -2+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, -2.5+x, 2+y, 24.5+z),\r\n      \r\n      \r\n        \r\n \r\n                \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, 0.5+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, 1+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, 1.5+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, 2+x, 2+y,24.5+z),\r\n        new BowlingPin(scene, 2.5+x, 2+y, 24.5+z),\r\n        new BowlingPin(scene, 3+x, 2+y, 24.5+z),\r\n       \r\n\r\n\r\n        \r\n        //5\r\n\r\n        new BowlingPin(scene, -0.5+x, 2+y, 25+z),\r\n        new BowlingPin(scene, -1+x, 2+y, 25+z),\r\n        new BowlingPin(scene, -1.5+x, 2+y, 25+z),\r\n        new BowlingPin(scene, -2+x, 2+y, 25+z),\r\n        new BowlingPin(scene, -2.5+x, 2+y, 25+z),\r\n        new BowlingPin(scene, -3+x, 2+y, 25+z),\r\n      \r\n        \r\n \r\n                \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 25+z),\r\n        new BowlingPin(scene, 0.5+x, 2+y, 25+z),\r\n        new BowlingPin(scene, 1+x, 2+y, 25+z),\r\n        new BowlingPin(scene, 1.5+x, 2+y, 25+z),\r\n        new BowlingPin(scene, 2+x, 2+y, 25+z),\r\n        new BowlingPin(scene, 2.5+x, 2+y, 25+z),\r\n        new BowlingPin(scene, 3+x, 2+y, 25+z),\r\n        new BowlingPin(scene, 3.5+x, 2+y, 25+z),\r\n        //new BowlingPin(scene, 4, 2, 25),\r\n        \r\n        \r\n\r\n       //6\r\n       \r\n        new BowlingPin(scene, -0.5+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, -1+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, -1.5+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, -2+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, -2.5+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, -3+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, -3.5+x, 2+y, 25.5+z),\r\n        \r\n \r\n                \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, 0.5+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, 1+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, 1.5+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, 2+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, 2.5+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, 3+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, 3.5+x, 2+y, 25.5+z),\r\n        new BowlingPin(scene, 4+x, 2+y, 25.5+z),\r\n   \r\n        \r\n\r\n        //7\r\n        new BowlingPin(scene, -0.5+x, 2+y, 26+z),\r\n        new BowlingPin(scene, -1+x, 2+y, 26+z),\r\n        new BowlingPin(scene, -1.5+x, 2+y, 26+z),\r\n        new BowlingPin(scene, -2+x, 2+y, 26+z),\r\n        new BowlingPin(scene, -2.5+x, 2+y, 26+z),\r\n        new BowlingPin(scene, -3+x, 2+y, 26+z),\r\n        new BowlingPin(scene, -3.5+x, 2+y, 26+z),\r\n        new BowlingPin(scene, -4+x, 2+y, 26+z),\r\n \r\n                \r\n        \r\n        new BowlingPin(scene, 0+x, 2+y, 26+z),\r\n        new BowlingPin(scene, 0.5+x, 2+y, 26+z),\r\n        new BowlingPin(scene, 1+x, 2+y, 26+z),\r\n        new BowlingPin(scene, 1.5+x, 2+y, 26+z),  \r\n        new BowlingPin(scene, 2+x, 2+y, 26+z),\r\n        new BowlingPin(scene, 2.5+x, 2+y, 26+z),\r\n        new BowlingPin(scene, 3+x, 2+y, 26+z),\r\n        new BowlingPin(scene, 3.5+x, 2+y, 26+z),\r\n        new BowlingPin(scene, 4+x, 2+y, 26+z),\r\n        new BowlingPin(scene, 4.5+x, 2+y, 26+z),\r\n\r\n        //listeQuilles1.forEach(pin => pin.position.y += 5)\r\n    \r\n     \r\n    ];\r\n    return listeQuilles1;\r\n}\r\n\r\nfunction respawnPlayerInput() {\r\n    // Ajouter un écouteur d'événements pour la touche \"espace\"\r\n    document.addEventListener('keydown', function(event) {\r\n        if (event.key === 'Shift') {\r\n            // Code à exécuter lorsque la touche \"espace\" est enfoncée\r\n            // Par exemple :\r\n            console.log('La touche \"espace\" a été enfoncée');\r\n            let ball1 = scene.getMeshByName(\"player1\");\r\n            player1.disableThisObject();\r\n            ball1.dispose();\r\n            player1 = new PlayerLevel3(scene,engine,\"player1\",'q','d','s',' ',0,8,-8);\r\n            \r\n        //document.getElementById(\"pin1\").innerText = countPlayer1+\"/93 PINS\";\r\n        \r\n        // Modifier le texte de l'élément avec l'identifiant \"pin2\"\r\n  \r\n        }\r\n    });\r\n\r\n    // Ajouter un écouteur d'événements pour la touche \"entrée\"\r\n    document.addEventListener('keydown', function(event) {\r\n        if (event.code === 'Backspace') {\r\n            // Code à exécuter lorsque la touche \"entrée\" est enfoncée\r\n            // Par exemple :\r\n            console.log('La touche \"entrée\" a été enfoncée');\r\n            let ball2 = scene.getMeshByName(\"player2\");\r\n            player2.disableThisObject();\r\n            ball2.dispose();\r\n            player2 = new PlayerLevel3(scene,engine,\"player2\",'ArrowLeft','ArrowRight','i','Enter',25,8,-8);\r\n            //document.getElementById(\"pin2\").innerText = countPlayer2+\"/93 PINS\";\r\n       \r\n        }\r\n    });\r\n\r\n}\r\n\r\n\r\nfunction displayPinNumber(){\r\n    \r\n     advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n    var button1 = BABYLON.GUI.Button.CreateSimpleButton(\"but1\", \"Click Me\");\r\n    button1.width = \"1000px\"\r\n    button1.height = \"40px\";\r\n    button1.color = \"white\";\r\n    button1.cornerRadius = 20;\r\n    button1.background = \"green\";\r\n    button1.onPointerUpObservable.add(function() {\r\n        alert(\"you did it!\");\r\n    });\r\n    advancedTexture.addControl(button1);   \r\n    \r\n    \r\n\r\n}\r\n\r\nfunction loadNextLevel(){\r\n    \r\n    sceneManager.launchEnd();\r\n\r\n}\r\nfunction killLevel(){\r\n    //scene.dispose();\r\n     \r\n    scene.meshes.forEach(function(mesh) {\r\n        mesh.dispose();\r\n    });\r\n   \r\n    scene.cameras.forEach(function(mesh) {\r\n        mesh.dispose();\r\n    });\r\n    // Supprimer toutes les lumières de la scène\r\n    scene.lights.forEach(function(light) {\r\n        light.dispose();\r\n    });\r\n\r\n    \r\n    engine.stopRenderLoop();\r\n    hideControlUI();\r\n}\r\n\r\nfunction displayControlUI(){\r\n  \r\n    // Récupération de l'élément par son ID\r\n    var level1 = document.getElementById(\"level3\");\r\n \r\n    // Afficher l'élément\r\n    level1.style.display = \"block\";\r\n \r\n }\r\n function hideControlUI(){\r\n        // Récupération de l'élément par son ID\r\n    var level1 = document.getElementById(\"level3\");\r\n \r\n    // Afficher l'élément\r\n    level1.style.display = \"none\";\r\n \r\n }\r\n\r\nexport { name, scene, sceneData, launch };\r\n","let advancedTexture ;\r\nlet advancedTexture2 ;\r\n//const BABYLON = require('babylonjs');\r\n\r\n\r\n\r\nvar canvas = document.getElementById(\"renderCanvas\");\r\nvar engine = new BABYLON.Engine(canvas, true);\r\nvar scene = new BABYLON.Scene(engine);\r\nimport { CustomModels } from './CustomModels.js';\r\nimport * as sceneManager from './SceneManager.js'\r\nvar createScene = function () {\r\n    \r\n    // GUI\r\n    // Ajoutez une lumière\r\n    var light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n\r\n   // Création d'une caméra\r\n    const camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 8, -50), scene);\r\n    //camera.attachControl()\r\n  \r\n   \r\n\r\n    let menu = new CustomModels(scene);\r\n    menu.CreateMenu3dScene(0,0,0);\r\n\r\n    displayMenu();\r\n\r\n    //scene.debugLayer.show();\r\n    return scene;\r\n};\r\nfunction launch(){\r\n    createScene();\r\n\r\n    engine.runRenderLoop(function () {\r\n        \r\n        scene.render();\r\n    });\r\n    \r\n\r\n}\r\n\r\nfunction displayMenu(){\r\n\r\n\r\n       // Création du GUI\r\n    advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI_button\");\r\n    advancedTexture2 = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI_text\");\r\n    // Création du bouton Play\r\n    const playButton = BABYLON.GUI.Button.CreateSimpleButton(\"playButton\", \"Play\");\r\n    playButton.width = \"150px\";\r\n    playButton.height = \"40px\";\r\n    playButton.color = \"white\";\r\n    playButton.background = \"grey\";\r\n    playButton.onPointerClickObservable.add(function () {\r\n        // Mettre ici la logique pour le bouton Play\r\n        console.log(\"Play button clicked\");\r\n        killLevel();\r\n        loadNextLevel();\r\n    });\r\n    advancedTexture.addControl(playButton);\r\n\r\n    \r\n    // Création du texte en haut de la page\r\n    const headerText = new BABYLON.GUI.TextBlock();\r\n    headerText.text = \"Les Jeux Olympiques Maudits\";\r\n    headerText.color = \"white\";\r\n    headerText.fontSize = 24;\r\n    headerText.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    headerText.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP; // Modifier cette ligne\r\n    headerText.paddingTop = \"-400px\"; // Ajout de 20px de padding en haut\r\n    advancedTexture2.addControl(headerText);\r\n\r\n\r\n  \r\n\r\n}\r\n\r\nfunction killLevel(player){\r\n    //scene.dispose();\r\n     \r\n    scene.meshes.forEach(function(mesh) {\r\n        mesh.dispose();\r\n    });\r\n   \r\n    scene.cameras.forEach(function(mesh) {\r\n        mesh.dispose();\r\n    });\r\n    // Supprimer toutes les lumières de la scène\r\n    scene.lights.forEach(function(light) {\r\n        light.dispose();\r\n    });\r\n    advancedTexture2.dispose();\r\n    advancedTexture.dispose();\r\n    engine.stopRenderLoop();\r\n}\r\n\r\n\r\nfunction loadNextLevel(){\r\n    \r\n    sceneManager.launchLevel2();\r\n\r\n}\r\n\r\nexport {  scene, launch };","// Importez les modules \"scene1.js\" et \"scene2.js\" pour accéder à leurs fonctionnalités\r\n\r\nimport * as end from './End.js';\r\nimport * as scene2 from './scene2.js'\r\nimport * as scene3 from './scene3.js'\r\nimport * as scene4 from './scene4.js'\r\nimport * as menu from './Menu.js'\r\n\r\nlet winCountPlayer1 =0;\r\nlet winCountPlayer2 =0;\r\n// Fonction principale\r\nfunction Main() {\r\n    \r\n    // Appelez la fonction \"launch\" du module \"level2\" pour lancer la scène 2\r\n    \r\n    //launchEnd();\r\n   \r\n    //launchLevel2();\r\n   //launchLevel3();\r\n   //launchLevel4();\r\n\r\n    launchLevelMenu();\r\n    \r\n\r\n   \r\n}\r\nfunction launchLevelMenu(){\r\n    \r\n    menu.launch();\r\n}\r\nfunction launchEnd(){\r\n    \r\n    end.launch();\r\n}\r\nfunction launchLevel2(){\r\n    scene2.killLevel();\r\n    scene2.launch();\r\n}\r\n\r\n\r\nfunction launchLevel3(){\r\n    \r\n   scene3.launch();\r\n}\r\n\r\nfunction launchLevel4(){\r\n    \r\n    scene4.launch();\r\n}\r\n\r\n\r\nfunction setcountPlayer1(){\r\n    winCountPlayer1++;\r\n}\r\nfunction setcountPlayer2(){\r\n    winCountPlayer2++;\r\n}\r\n \r\n// Exportez toutes les fonctions d'un coup\r\nexport { Main, launchEnd, launchLevel2, launchLevel3, launchLevel4,setcountPlayer1,setcountPlayer2,winCountPlayer1,winCountPlayer2 };\r\n\r\n\r\n// Exécute la fonction principale\r\nMain();\r\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","canvas","document","getElementById","engine","BABYLON","Engine","scene","Scene","createScene","HemisphericLight","Vector3","FreeCamera","attachControl","playerWin","playerLoose","debugLayer","show","style","display","SceneLoader","ImportMesh","meshes","console","log","mesh","name","position","x","y","z","undefined","CustomModels","constructor","this","CreateTree","tree","tronc","PhysicsAggregate","PhysicsShapeType","BOX","mass","shape","isTrigger","boundingBox","CreatePineTree","scaling","shapeBox1","PhysicsShapeBox","Quaternion","shapeBox2","CreateSnowManOnSki","parent","setParent","CreateSceneProd","CreatePlayer","Zone","plane","width","height","ground","MeshBuilder","CreateGround","subdivisions","addInPlace","rotation","groundMaterial","StandardMaterial","diffuseColor","Color3","material","flatplane","createDeadTree","globalMesh","createSnowTree","createLitleSnowTree","createSnowMan","CreateRampe1","bigMesh","elment","MESH","createSnowMount","element","createFinalScene2","getMeshByName","i","length","CreatePlateform","CreatePlateformlevel2","CreatePlateform_Scene4","CreateBowlingPlatform","CreateBowlingBall","SPHERE","CreateColiseum","CreateMenu3dScene","Createlevel1","character","forward","backward","left","right","setupKeyboardInput","forwardI","keys","addEventListener","event","runRenderLoop","transformNode","scale","applyForce","setAngularVelocity","ZeroReadOnly","canvas2","PlayerLevel1","boxBody","testPlayer","enablePlayerControl","box","CreateBox","depth","isVisible","rotationQuaternion","Identity","boxShape","PhysicsBody","PhysicsMotionType","DYNAMIC","setMassProperties","blueMaterial","setCollisionCallbackEnabled","destroyPlayer","control","killLevel","player","forEach","dispose","cameras","lights","light","stopRenderLoop","reloadlevel","character1","input1","inputJump","animationGroup","setupKeyboardInputPlayer","isKeyPressed","isKeyPressed2","engine2","jump","boxMesh","animationGroups","createPlayer","visibility","Character","ImportMeshAsync","push","animGestionner","play","inputLeft","inputRight","inputLaunch","destroyed","action","input2","destroy","isUpperCase","input","toUpperCase","getLastKeyPressed","lastKeyPressed","sphereBody","rayHelper","shootBall","control2","CharacterController3","raycast","playerMesh","rayOrigin","rayDirection","ray","add","Ray","RayHelper","pickWithRay","error","sphere","CreateSphere","segments","diameter","sphereShape","PhysicsShapeSphere","disableThisObject","instanciate","Aggregate","meshIdPromise","createBowlingPin","Promise","resolve","_z","body","meshId","uniqueId","getMeshId","isPinUp","toEulerAngles","Math","abs","player1","player2","advancedTexture2","countPlayer1","countPlayer2","async","havokInstance","HavokPhysics","hk","HavokPlugin","enablePhysics","collisionsEnabled","model","listeQuilles1","listeQuilles2","onTriggerCollisionObservable","ev","type","collider","collidedAgainst","ball1","ball2","addQuille","countPlayer","playerText","splice","innerHTML","testSearch","testSearch2","code","winCountPlayer1","winCountPlayer2","launchEnd","render","launchLevel2","camera","FollowCamera","cameraRotation","viewport","Viewport","camera2","activeCameras","triggerDie","eventHandler","sceneData","then","playerMesh2","lockedTarget","catch","launchLevel3","triggerEnd","onPointerDown","evt","pickResult","hit","pickedMesh","playerMesh1","launchLevel4","inertia","angularSensibility","detachControl","setcountPlayer1","setcountPlayer2","GUI","AdvancedDynamicTexture","CreateFullscreenUI","playButton","Button","CreateSimpleButton","color","background","onPointerClickObservable","addControl","headerText","TextBlock","text","fontSize","horizontalAlignment","Control","HORIZONTAL_ALIGNMENT_CENTER","verticalAlignment","VERTICAL_ALIGNMENT_TOP","paddingTop","displayMenu"],"sourceRoot":""}